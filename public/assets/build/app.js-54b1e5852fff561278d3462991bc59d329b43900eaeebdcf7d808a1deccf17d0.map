{"version":3,"sources":["webpack:///webpack/bootstrap f787b4909047f4e26b02","webpack:///./src/index.js","webpack:///./~/mithril/mithril.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/superagent/lib/client.js","webpack:///./~/component-emitter/index.js","webpack:///./~/reduce-component/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACtCA,KAAM,CAAC,GAAG,mBAAO,CAAC,CAAS,CAAC,CAAC;AAC7B,KAAM,OAAO,GAAG,mBAAO,CAAC,CAAY,CAAC,CAAC;;AAEtC,KAAI,GAAG,GAAG,EAAE,CAAC;;AAEb,KAAM,QAAQ,GAAG,SAAX,QAAQ,GAAS;AACrB,OAAI,CAAC,GAAG,CAAC,CAAC;AACV,OAAI,CAAC,GAAG,sCAAsC,CAAC;AAC/C,OAAI,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC;AAClB,OAAI,CAAC,GAAG,EAAE,CAAC;AACX,QAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;AAC1B,MAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;IACxC;AACD,UAAO,CAAC;EACT;AACD,IAAG,CAAC,SAAS,GAAG,UAAC,EAAE,EAAK;AACtB,IAAC,CAAC,gBAAgB,EAAE,CAAC;AACrB,OAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;AAChD,UAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CACpB,IAAI,CAAC,IAAI,CAAC,CACV,GAAG,CAAC,UAAC,GAAG,EAAE,GAAG,EAAK;AACjB,YAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACjB,QAAG,CAAC,MAAM,cAAY,GAAG,CAAC,IAAI,CAAC,EAAI;AACnC,MAAC,CAAC,cAAc,EAAE,CAAC;IACpB,CAAC;EACL;AACD,IAAG,CAAC,MAAM,GAAG,IAAI;AACjB,IAAG,CAAC,UAAU,GAAG,YAAM;AACrB,OAAI,OAAO,GAAG,GAAG,CAAC,SAAS,CAAC;AAC5B,OAAI,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;AACxB,UAAO;AACL,WAAM,EAAN,MAAM;AACN,WAAM,kBAAC,EAAE,EAAE;AACT,cAAO,CAAC,EAAE,CAAC,CAAC;MACb;IACF;EACF;;AAED,KAAM,OAAO,GAAG,SAAV,OAAO,CAAI,MAAM,EAAE,IAAI,EAAK;AAChC,OAAI,SAAS,GAAG;AACd,WAAM,EAAE,MAAM;AACd,YAAO,EAAE,qBAAqB;IAC/B,CAAC;AACF,OAAG,MAAM,EAAE;AACT,SAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,GAAC,UAAU;AAC7C,YACE,CACA,CAAC,CAAC,KAAK,EAAC,EAAC,GAAG,EAAE,MAAM,EAAC,CAAC,EACtB,CAAC,CAAC,IAAI,EAAC,OAAO,CAAC,EACf,CAAC,CAAC,GAAG,EAAC,EAAC,IAAI,6CAA2C,KAAK,aAAQ,KAAO,EAAC,EAAC,OAAO,CAAC,CACnF,CACF;IACF,MAAM;AACL,YACE,CACA,CAAC,CAAC,GAAG,EAAC,yBAAyB,CAAC,EAChC,CAAC,CAAC,MAAM,EAAC,SAAS,EAAC,CACjB,CAAC,CAAC,OAAO,EAAE,EAAC,KAAK,EAAE,YAAY,EAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,EAAE,OAAO,EAAE,qBAAqB,EAAC,CAAC,EAChG,CAAC,CAAC,OAAO,EAAE,EAAC,KAAK,EAAE,iBAAiB,EAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,MAAM,EAAC,CAAC,CACzF,CAAC,CACH,CACF;IACA;EACF;;AAED,IAAG,CAAC,IAAI,GAAG,UAAC,IAAI,EAAK;AACnB,OAAI,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;AAC1C,UAAO,CAAC,CAAC,KAAK,EACd,CAAC,SAAS,CAAC,CACV;EACF;;AAED,EAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC,C;;;;;;mCCxE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA,aAAY,IAAI;AAChB,aAAY,UAAU;AACtB,aAAY,YAAY;AACxB;AACA;AACA;AACA,6BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,aAAa;AAChB;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,IAAI;AACR,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,2BAA2B;AACxC;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,qBAAqB;AACtE,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA,qCAAoC;AACpC,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,SAAS;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gEAA+D;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,sFAAqF,wBAAwB,IAAI;AACjH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAmD,qDAAqD;AACxG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yIAAwI;AACxI;AACA,kDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAkE;AAClE,wDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,iDAAiD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA,UAAS,2CAA2C;AACpD,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA8D,qBAAqB;AACnF,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,iCAAiC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA,uCAAsC,UAAU,EAAE;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,uDAAsD;AACtD;AACA;AACA;AACA,6BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iGAAgG,iBAAiB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD,qBAAqB,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6DAA4D,EAAE;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA,4BAA2B,cAAc;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE,0BAA0B;AAC1F,4BAA2B,2BAA2B;AACtD;AACA;AACA;AACA,4DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,4BAA4B;AACvE;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,OAAM;AACN;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC,6CAA6C;;AAE9C;AACA,8DAAwE,WAAW;;;;;;;;ACv3CnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAoC;AACpC;AACA,EAAC,wCAAwC;AACzC;AACA,EAAC,OAAO;AACR;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA,eAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,UAAS,+CAA+C,EAAE;AAC1D,UAAS,gDAAgD,EAAE;AAC3D,UAAS,gDAAgD,EAAE;AAC3D,UAAS,4CAA4C,EAAE;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC,kBAAiB,sCAAsC;;AAEvD;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC,SAAS;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc;;AAEd,sCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA,+BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA,IAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,kBAAiB,aAAa;AAC9B,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAiB,aAAa,iBAAiB;AAC/C;AACA;AACA;AACA;AACA,2BAA0B,aAAa;AACvC,+BAA8B;AAC9B;AACA;AACA;AACA;AACA,2BAA0B,aAAa,iBAAiB;AACxD;AACA,YAAW,eAAe;AAC1B,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,oDAAoD;AACpE;AACA;AACA,YAAW,cAAc;AACzB,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,gBAAgB;AAC9B;AACA,WAAU,cAAc;AACxB,YAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,iBAAiB;AAC5B,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D,mBAAmB;AAChF;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,UAAU;AACrB,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,kBAAkB;AACpC,mBAAkB,gBAAgB;AAClC,mBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,mBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,cAAc;AACzB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS,sBAAsB,WAAW,YAAY;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yFAAwF;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,aAAY;AACZ;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,gBAAgB;AAC3B,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,eAAe;AAC1B,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,eAAe;AAC1B,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,eAAe;AAC1B,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC/qCA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;;;;;;;AClKA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB;AACA;AACA;;AAEA,6C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,G","file":"../build/app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f787b4909047f4e26b02\n **/","const m = require(\"mithril\");\nconst request = require(\"superagent\");\n\nlet app = {};\n\nconst makeRand = () => {\n  var l = 8;\n  var c = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n  var cl = c.length;\n  var r = \"\";\n  for (var i = 0; i < l; i++) {\n    r += c[Math.floor(Math.random() * cl)];\n  }\n  return r\n}\napp.imgUpload = (ev) => {\n  m.startComputation();\n  const data = new FormData(ev.target.parentNode);\n  request.post(\"/upload\")\n    .send(data)\n    .end((err, res) => {\n      console.log(res);\n      app.imgUrl = `/show/${res.body.id}`\n      m.endComputation();\n    })\n}\napp.imgUrl = null\napp.controller = () => {\n  let upImage = app.imgUpload;\n  let imgUrl = app.imgUrl;\n  return {\n    imgUrl,\n    submit(ev) {\n      upImage(ev);\n    }\n  }\n}\n\nconst imgView = (imgUrl, ctrl) => {\n  let formParam = {\n    method: \"post\",\n    encType: \"multipart/form-data\"\n  };\n  if(imgUrl) {\n    const tweet = window.location.href+\"であけおめがぞう\"\n    return (\n      [\n      m(\"img\",{src: imgUrl}),\n      m(\"h2\",\"よいお年を\"),\n      m(\"a\",{href: `https://twitter.com/intent/tweet?text=${tweet}&url=${tweet}`},\"tweet\")\n      ]\n    )\n  } else {\n    return (\n      [\n      m(\"p\",\"画像をupするとあけおめ入りにするよ（たぶん）\"),\n      m(\"form\",formParam,[\n        m(\"input\", {class: \"form-group\",type: \"file\", name: makeRand(), encType: \"multipart/form-data\"}),\n        m(\"input\", {class: \"btn btn-default\",type: \"button\", value: \"送信\", onclick: ctrl.submit})\n      ])\n    ]\n  )\n  }\n}\n\napp.view = (ctrl) => {\n  let component = imgView(app.imgUrl, ctrl);\n  return m(\"div\",\n  [component]\n  )\n}\n\nm.mount(document.getElementById(\"app\"), app);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","var m = (function app(window, undefined) {\r\n\t\"use strict\";\r\n  \tvar VERSION = \"v0.2.2-rc.1\";\r\n\tfunction isFunction(object) {\r\n\t\treturn typeof object === \"function\";\r\n\t}\r\n\tfunction isObject(object) {\r\n\t\treturn type.call(object) === \"[object Object]\";\r\n\t}\r\n\tfunction isString(object) {\r\n\t\treturn type.call(object) === \"[object String]\";\r\n\t}\r\n\tvar isArray = Array.isArray || function (object) {\r\n\t\treturn type.call(object) === \"[object Array]\";\r\n\t};\r\n\tvar type = {}.toString;\r\n\tvar parser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[.+?\\])/g, attrParser = /\\[(.+?)(?:=(\"|'|)(.*?)\\2)?\\]/;\r\n\tvar voidElements = /^(AREA|BASE|BR|COL|COMMAND|EMBED|HR|IMG|INPUT|KEYGEN|LINK|META|PARAM|SOURCE|TRACK|WBR)$/;\r\n\tvar noop = function () {};\r\n\r\n\t// caching commonly used variables\r\n\tvar $document, $location, $requestAnimationFrame, $cancelAnimationFrame;\r\n\r\n\t// self invoking function needed because of the way mocks work\r\n\tfunction initialize(window) {\r\n\t\t$document = window.document;\r\n\t\t$location = window.location;\r\n\t\t$cancelAnimationFrame = window.cancelAnimationFrame || window.clearTimeout;\r\n\t\t$requestAnimationFrame = window.requestAnimationFrame || window.setTimeout;\r\n\t}\r\n\r\n\tinitialize(window);\r\n\r\n\tm.version = function() {\r\n\t\treturn VERSION;\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {String} Tag\r\n\t * A string that looks like -> div.classname#id[param=one][param2=two]\r\n\t * Which describes a DOM node\r\n\t */\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Tag} The DOM node tag\r\n\t * @param {Object=[]} optional key-value pairs to be mapped to DOM attrs\r\n\t * @param {...mNode=[]} Zero or more Mithril child nodes. Can be an array, or splat (optional)\r\n\t *\r\n\t */\r\n\tfunction m(tag, pairs) {\r\n\t\tfor (var args = [], i = 1; i < arguments.length; i++) {\r\n\t\t\targs[i - 1] = arguments[i];\r\n\t\t}\r\n\t\tif (isObject(tag)) return parameterize(tag, args);\r\n\t\tvar hasAttrs = pairs != null && isObject(pairs) && !(\"tag\" in pairs || \"view\" in pairs || \"subtree\" in pairs);\r\n\t\tvar attrs = hasAttrs ? pairs : {};\r\n\t\tvar classAttrName = \"class\" in attrs ? \"class\" : \"className\";\r\n\t\tvar cell = {tag: \"div\", attrs: {}};\r\n\t\tvar match, classes = [];\r\n\t\tif (!isString(tag)) throw new Error(\"selector in m(selector, attrs, children) should be a string\");\r\n\t\twhile ((match = parser.exec(tag)) != null) {\r\n\t\t\tif (match[1] === \"\" && match[2]) cell.tag = match[2];\r\n\t\t\telse if (match[1] === \"#\") cell.attrs.id = match[2];\r\n\t\t\telse if (match[1] === \".\") classes.push(match[2]);\r\n\t\t\telse if (match[3][0] === \"[\") {\r\n\t\t\t\tvar pair = attrParser.exec(match[3]);\r\n\t\t\t\tcell.attrs[pair[1]] = pair[3] || (pair[2] ? \"\" :true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar children = hasAttrs ? args.slice(1) : args;\r\n\t\tif (children.length === 1 && isArray(children[0])) {\r\n\t\t\tcell.children = children[0];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcell.children = children;\r\n\t\t}\r\n\r\n\t\tfor (var attrName in attrs) {\r\n\t\t\tif (attrs.hasOwnProperty(attrName)) {\r\n\t\t\t\tif (attrName === classAttrName && attrs[attrName] != null && attrs[attrName] !== \"\") {\r\n\t\t\t\t\tclasses.push(attrs[attrName]);\r\n\t\t\t\t\tcell.attrs[attrName] = \"\"; //create key in correct iteration order\r\n\t\t\t\t}\r\n\t\t\t\telse cell.attrs[attrName] = attrs[attrName];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (classes.length) cell.attrs[classAttrName] = classes.join(\" \");\r\n\r\n\t\treturn cell;\r\n\t}\r\n\tfunction forEach(list, f) {\r\n\t\tfor (var i = 0; i < list.length && !f(list[i], i++);) {}\r\n\t}\r\n\tfunction forKeys(list, f) {\r\n\t\tforEach(list, function (attrs, i) {\r\n\t\t\treturn (attrs = attrs && attrs.attrs) && attrs.key != null && f(attrs, i);\r\n\t\t});\r\n\t}\r\n\t// This function was causing deopts in Chrome.\r\n\tfunction dataToString(data) {\r\n\t\t//data.toString() might throw or return null if data is the return value of Console.log in Firefox (behavior depends on version)\r\n\t\ttry {\r\n\t\t\tif (data == null || data.toString() == null) return \"\";\r\n\t\t} catch (e) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t\treturn data;\r\n\t}\r\n\t// This function was causing deopts in Chrome.\r\n\tfunction injectTextNode(parentElement, first, index, data) {\r\n\t\ttry {\r\n\t\t\tinsertNode(parentElement, first, index);\r\n\t\t\tfirst.nodeValue = data;\r\n\t\t} catch (e) {} //IE erroneously throws error when appending an empty text node after a null\r\n\t}\r\n\r\n\tfunction flatten(list) {\r\n\t\t//recursively flatten array\r\n\t\tfor (var i = 0; i < list.length; i++) {\r\n\t\t\tif (isArray(list[i])) {\r\n\t\t\t\tlist = list.concat.apply([], list);\r\n\t\t\t\t//check current index again and flatten until there are no more nested arrays at that index\r\n\t\t\t\ti--;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn list;\r\n\t}\r\n\r\n\tfunction insertNode(parentElement, node, index) {\r\n\t\tparentElement.insertBefore(node, parentElement.childNodes[index] || null);\r\n\t}\r\n\r\n\tvar DELETION = 1, INSERTION = 2, MOVE = 3;\r\n\r\n\tfunction handleKeysDiffer(data, existing, cached, parentElement) {\r\n\t\tforKeys(data, function (key, i) {\r\n\t\t\texisting[key = key.key] = existing[key] ? {\r\n\t\t\t\taction: MOVE,\r\n\t\t\t\tindex: i,\r\n\t\t\t\tfrom: existing[key].index,\r\n\t\t\t\telement: cached.nodes[existing[key].index] || $document.createElement(\"div\")\r\n\t\t\t} : {action: INSERTION, index: i};\r\n\t\t});\r\n\t\tvar actions = [];\r\n\t\tfor (var prop in existing) actions.push(existing[prop]);\r\n\t\tvar changes = actions.sort(sortChanges), newCached = new Array(cached.length);\r\n\t\tnewCached.nodes = cached.nodes.slice();\r\n\r\n\t\tforEach(changes, function (change) {\r\n\t\t\tvar index = change.index;\r\n\t\t\tif (change.action === DELETION) {\r\n\t\t\t\tclear(cached[index].nodes, cached[index]);\r\n\t\t\t\tnewCached.splice(index, 1);\r\n\t\t\t}\r\n\t\t\tif (change.action === INSERTION) {\r\n\t\t\t\tvar dummy = $document.createElement(\"div\");\r\n\t\t\t\tdummy.key = data[index].attrs.key;\r\n\t\t\t\tinsertNode(parentElement, dummy, index);\r\n\t\t\t\tnewCached.splice(index, 0, {\r\n\t\t\t\t\tattrs: {key: data[index].attrs.key},\r\n\t\t\t\t\tnodes: [dummy]\r\n\t\t\t\t});\r\n\t\t\t\tnewCached.nodes[index] = dummy;\r\n\t\t\t}\r\n\r\n\t\t\tif (change.action === MOVE) {\r\n\t\t\t\tvar changeElement = change.element;\r\n\t\t\t\tvar maybeChanged = parentElement.childNodes[index];\r\n\t\t\t\tif (maybeChanged !== changeElement && changeElement !== null) {\r\n\t\t\t\t\tparentElement.insertBefore(changeElement, maybeChanged || null);\r\n\t\t\t\t}\r\n\t\t\t\tnewCached[index] = cached[change.from];\r\n\t\t\t\tnewCached.nodes[index] = changeElement;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn newCached;\r\n\t}\r\n\r\n\tfunction diffKeys(data, cached, existing, parentElement) {\r\n\t\tvar keysDiffer = data.length !== cached.length;\r\n\t\tif (!keysDiffer) {\r\n\t\t\tforKeys(data, function (attrs, i) {\r\n\t\t\t\tvar cachedCell = cached[i];\r\n\t\t\t\treturn keysDiffer = cachedCell && cachedCell.attrs && cachedCell.attrs.key !== attrs.key;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn keysDiffer ? handleKeysDiffer(data, existing, cached, parentElement) : cached;\r\n\t}\r\n\r\n\tfunction diffArray(data, cached, nodes) {\r\n\t\t//diff the array itself\r\n\r\n\t\t//update the list of DOM nodes by collecting the nodes from each item\r\n\t\tforEach(data, function (_, i) {\r\n\t\t\tif (cached[i] != null) nodes.push.apply(nodes, cached[i].nodes);\r\n\t\t})\r\n\t\t//remove items from the end of the array if the new array is shorter than the old one. if errors ever happen here, the issue is most likely\r\n\t\t//a bug in the construction of the `cached` data structure somewhere earlier in the program\r\n\t\tforEach(cached.nodes, function (node, i) {\r\n\t\t\tif (node.parentNode != null && nodes.indexOf(node) < 0) clear([node], [cached[i]]);\r\n\t\t})\r\n\t\tif (data.length < cached.length) cached.length = data.length;\r\n\t\tcached.nodes = nodes;\r\n\t}\r\n\r\n\tfunction buildArrayKeys(data) {\r\n\t\tvar guid = 0;\r\n\t\tforKeys(data, function () {\r\n\t\t\tforEach(data, function (attrs) {\r\n\t\t\t\tif ((attrs = attrs && attrs.attrs) && attrs.key == null) attrs.key = \"__mithril__\" + guid++;\r\n\t\t\t})\r\n\t\t\treturn 1;\r\n\t\t});\r\n\t}\r\n\r\n\tfunction maybeRecreateObject(data, cached, dataAttrKeys) {\r\n\t\t//if an element is different enough from the one in cache, recreate it\r\n\t\tif (data.tag !== cached.tag ||\r\n\t\t\t\tdataAttrKeys.sort().join() !== Object.keys(cached.attrs).sort().join() ||\r\n\t\t\t\tdata.attrs.id !== cached.attrs.id ||\r\n\t\t\t\tdata.attrs.key !== cached.attrs.key ||\r\n\t\t\t\t(m.redraw.strategy() === \"all\" && (!cached.configContext || cached.configContext.retain !== true)) ||\r\n\t\t\t\t(m.redraw.strategy() === \"diff\" && cached.configContext && cached.configContext.retain === false)) {\r\n\t\t\tif (cached.nodes.length) clear(cached.nodes);\r\n\t\t\tif (cached.configContext && isFunction(cached.configContext.onunload)) cached.configContext.onunload();\r\n\t\t\tif (cached.controllers) {\r\n\t\t\t\tforEach(cached.controllers, function (controller) {\r\n\t\t\t\t\tif (controller.unload) controller.onunload({preventDefault: noop});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getObjectNamespace(data, namespace) {\r\n\t\treturn data.attrs.xmlns ? data.attrs.xmlns :\r\n\t\t\tdata.tag === \"svg\" ? \"http://www.w3.org/2000/svg\" :\r\n\t\t\tdata.tag === \"math\" ? \"http://www.w3.org/1998/Math/MathML\" :\r\n\t\t\tnamespace;\r\n\t}\r\n\r\n\tfunction unloadCachedControllers(cached, views, controllers) {\r\n\t\tif (controllers.length) {\r\n\t\t\tcached.views = views;\r\n\t\t\tcached.controllers = controllers;\r\n\t\t\tforEach(controllers, function (controller) {\r\n\t\t\t\tif (controller.onunload && controller.onunload.$old) controller.onunload = controller.onunload.$old;\r\n\t\t\t\tif (pendingRequests && controller.onunload) {\r\n\t\t\t\t\tvar onunload = controller.onunload;\r\n\t\t\t\t\tcontroller.onunload = noop;\r\n\t\t\t\t\tcontroller.onunload.$old = onunload;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction scheduleConfigsToBeCalled(configs, data, node, isNew, cached) {\r\n\t\t//schedule configs to be called. They are called after `build`\r\n\t\t//finishes running\r\n\t\tif (isFunction(data.attrs.config)) {\r\n\t\t\tvar context = cached.configContext = cached.configContext || {};\r\n\r\n\t\t\t//bind\r\n\t\t\tconfigs.push(function() {\r\n\t\t\t\treturn data.attrs.config.call(data, node, !isNew, context, cached);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildUpdatedNode(cached, data, editable, hasKeys, namespace, views, configs, controllers) {\r\n\t\tvar node = cached.nodes[0];\r\n\t\tif (hasKeys) setAttributes(node, data.tag, data.attrs, cached.attrs, namespace);\r\n\t\tcached.children = build(node, data.tag, undefined, undefined, data.children, cached.children, false, 0, data.attrs.contenteditable ? node : editable, namespace, configs);\r\n\t\tcached.nodes.intact = true;\r\n\r\n\t\tif (controllers.length) {\r\n\t\t\tcached.views = views;\r\n\t\t\tcached.controllers = controllers;\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\t}\r\n\r\n\tfunction handleNonexistentNodes(data, parentElement, index) {\r\n\t\tvar nodes;\r\n\t\tif (data.$trusted) {\r\n\t\t\tnodes = injectHTML(parentElement, index, data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnodes = [$document.createTextNode(data)];\r\n\t\t\tif (!parentElement.nodeName.match(voidElements)) insertNode(parentElement, nodes[0], index);\r\n\t\t}\r\n\r\n\t\tvar cached = typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\" ? new data.constructor(data) : data;\r\n\t\tcached.nodes = nodes;\r\n\t\treturn cached;\r\n\t}\r\n\r\n\tfunction reattachNodes(data, cached, parentElement, editable, index, parentTag) {\r\n\t\tvar nodes = cached.nodes;\r\n\t\tif (!editable || editable !== $document.activeElement) {\r\n\t\t\tif (data.$trusted) {\r\n\t\t\t\tclear(nodes, cached)\r\n\t\t\t\tnodes = injectHTML(parentElement, index, data)\r\n\t\t\t} else if (parentTag === \"textarea\") {\r\n\t\t\t\t// <textarea> uses `value` instead of `nodeValue`.\r\n\t\t\t\tparentElement.value = data\r\n\t\t\t} else if (editable) {\r\n\t\t\t\t// contenteditable nodes use `innerHTML` instead of `nodeValue`.\r\n\t\t\t\teditable.innerHTML = data\r\n\t\t\t} else {\r\n\t\t\t\t// was a trusted string\r\n\t\t\t\tif (nodes[0].nodeType === 1 || nodes.length > 1 || (nodes[0].nodeValue.trim && !nodes[0].nodeValue.trim())) {\r\n\t\t\t\t\tclear(cached.nodes, cached)\r\n\t\t\t\t\tnodes = [$document.createTextNode(data)]\r\n\t\t\t\t}\r\n\t\t\t\tinjectTextNode(parentElement, nodes[0], index, data);\r\n\t\t\t}\r\n\t\t}\r\n\t\tcached = new data.constructor(data);\r\n\t\tcached.nodes = nodes;\r\n\t\treturn cached;\r\n\t}\r\n\r\n\tfunction handleText(cached, data, index, parentElement, shouldReattach, editable, parentTag) {\r\n\t\t//handle text nodes\r\n\t\treturn cached.nodes.length === 0 ? handleNonexistentNodes(data, parentElement, index) :\r\n\t\t\tcached.valueOf() !== data.valueOf() || shouldReattach === true ?\r\n\t\t\t\treattachNodes(data, cached, parentElement, editable, index, parentTag) :\r\n\t\t\t(cached.nodes.intact = true, cached);\r\n\t}\r\n\r\n\tfunction getSubArrayCount(item) {\r\n\t\tif (item.$trusted) {\r\n\t\t\t//fix offset of next element if item was a trusted string w/ more than one html element\r\n\t\t\t//the first clause in the regexp matches elements\r\n\t\t\t//the second clause (after the pipe) matches text nodes\r\n\t\t\tvar match = item.match(/<[^\\/]|\\>\\s*[^<]/g);\r\n\t\t\tif (match != null) return match.length;\r\n\t\t}\r\n\t\telse if (isArray(item)) {\r\n\t\t\treturn item.length;\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tfunction buildArray(data, cached, parentElement, index, parentTag, shouldReattach, editable, namespace, configs) {\r\n\t\tdata = flatten(data);\r\n\t\tvar nodes = [], intact = cached.length === data.length, subArrayCount = 0;\r\n\r\n\t\t//keys algorithm: sort elements without recreating them if keys are present\r\n\t\t//1) create a map of all existing keys, and mark all for deletion\r\n\t\t//2) add new keys to map and mark them for addition\r\n\t\t//3) if key exists in new list, change action from deletion to a move\r\n\t\t//4) for each key, handle its corresponding action as marked in previous steps\r\n\t\tvar existing = {}, shouldMaintainIdentities = false;\r\n\t\tforKeys(cached, function (attrs, i) {\r\n\t\t\tshouldMaintainIdentities = true;\r\n\t\t\texisting[cached[i].attrs.key] = {action: DELETION, index: i};\r\n\t\t});\r\n\r\n\t\tbuildArrayKeys(data);\r\n\t\tif (shouldMaintainIdentities) cached = diffKeys(data, cached, existing, parentElement);\r\n\t\t//end key algorithm\r\n\r\n\t\tvar cacheCount = 0;\r\n\t\t//faster explicitly written\r\n\t\tfor (var i = 0, len = data.length; i < len; i++) {\r\n\t\t\t//diff each item in the array\r\n\t\t\tvar item = build(parentElement, parentTag, cached, index, data[i], cached[cacheCount], shouldReattach, index + subArrayCount || subArrayCount, editable, namespace, configs);\r\n\r\n\t\t\tif (item !== undefined) {\r\n\t\t\t\tintact = intact && item.nodes.intact;\r\n\t\t\t\tsubArrayCount += getSubArrayCount(item);\r\n\t\t\t\tcached[cacheCount++] = item;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!intact) diffArray(data, cached, nodes);\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction makeCache(data, cached, index, parentIndex, parentCache) {\r\n\t\tif (cached != null) {\r\n\t\t\tif (type.call(cached) === type.call(data)) return cached;\r\n\r\n\t\t\tif (parentCache && parentCache.nodes) {\r\n\t\t\t\tvar offset = index - parentIndex, end = offset + (isArray(data) ? data : cached.nodes).length;\r\n\t\t\t\tclear(parentCache.nodes.slice(offset, end), parentCache.slice(offset, end));\r\n\t\t\t} else if (cached.nodes) {\r\n\t\t\t\tclear(cached.nodes, cached);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcached = new data.constructor();\r\n\t\t//if constructor creates a virtual dom element, use a blank object\r\n\t\t//as the base cached node instead of copying the virtual el (#277)\r\n\t\tif (cached.tag) cached = {};\r\n\t\tcached.nodes = [];\r\n\t\treturn cached;\r\n\t}\r\n\r\n\tfunction constructNode(data, namespace) {\r\n\t\treturn namespace === undefined ?\r\n\t\t\tdata.attrs.is ? $document.createElement(data.tag, data.attrs.is) : $document.createElement(data.tag) :\r\n\t\t\tdata.attrs.is ? $document.createElementNS(namespace, data.tag, data.attrs.is) : $document.createElementNS(namespace, data.tag);\r\n\t}\r\n\r\n\tfunction constructAttrs(data, node, namespace, hasKeys) {\r\n\t\treturn hasKeys ? setAttributes(node, data.tag, data.attrs, {}, namespace) : data.attrs;\r\n\t}\r\n\r\n\tfunction constructChildren(data, node, cached, editable, namespace, configs) {\r\n\t\treturn data.children != null && data.children.length > 0 ?\r\n\t\t\tbuild(node, data.tag, undefined, undefined, data.children, cached.children, true, 0, data.attrs.contenteditable ? node : editable, namespace, configs) :\r\n\t\t\tdata.children;\r\n\t}\r\n\r\n\tfunction reconstructCached(data, attrs, children, node, namespace, views, controllers) {\r\n\t\tvar cached = {tag: data.tag, attrs: attrs, children: children, nodes: [node]};\r\n\t\tunloadCachedControllers(cached, views, controllers);\r\n\t\tif (cached.children && !cached.children.nodes) cached.children.nodes = [];\r\n\t\t//edge case: setting value on <select> doesn't work before children exist, so set it again after children have been created\r\n\t\tif (data.tag === \"select\" && \"value\" in data.attrs) setAttributes(node, data.tag, {value: data.attrs.value}, {}, namespace);\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction getController(views, view, cachedControllers, controller) {\r\n\t\tvar controllerIndex = m.redraw.strategy() === \"diff\" && views ? views.indexOf(view) : -1;\r\n\t\treturn controllerIndex > -1 ? cachedControllers[controllerIndex] :\r\n\t\t\ttypeof controller === \"function\" ? new controller() : {};\r\n\t}\r\n\r\n\tfunction updateLists(views, controllers, view, controller) {\r\n\t\tif (controller.onunload != null) unloaders.push({controller: controller, handler: controller.onunload});\r\n\t\tviews.push(view);\r\n\t\tcontrollers.push(controller);\r\n\t}\r\n\r\n\tfunction checkView(data, view, cached, cachedControllers, controllers, views) {\r\n\t\tvar controller = getController(cached.views, view, cachedControllers, data.controller);\r\n\t\t//Faster to coerce to number and check for NaN\r\n\t\tvar key = +(data && data.attrs && data.attrs.key);\r\n\t\tdata = pendingRequests === 0 || forcing || cachedControllers && cachedControllers.indexOf(controller) > -1 ? data.view(controller) : {tag: \"placeholder\"};\r\n\t\tif (data.subtree === \"retain\") return cached;\r\n\t\tif (key === key) (data.attrs = data.attrs || {}).key = key;\r\n\t\tupdateLists(views, controllers, view, controller);\r\n\t\treturn data;\r\n\t}\r\n\r\n\tfunction markViews(data, cached, views, controllers) {\r\n\t\tvar cachedControllers = cached && cached.controllers;\r\n\t\twhile (data.view != null) data = checkView(data, data.view.$original || data.view, cached, cachedControllers, controllers, views);\r\n\t\treturn data;\r\n\t}\r\n\r\n\tfunction buildObject(data, cached, editable, parentElement, index, shouldReattach, namespace, configs) {\r\n\t\tvar views = [], controllers = [];\r\n\t\tdata = markViews(data, cached, views, controllers);\r\n\t\tif (!data.tag && controllers.length) throw new Error(\"Component template must return a virtual element, not an array, string, etc.\");\r\n\t\tdata.attrs = data.attrs || {};\r\n\t\tcached.attrs = cached.attrs || {};\r\n\t\tvar dataAttrKeys = Object.keys(data.attrs);\r\n\t\tvar hasKeys = dataAttrKeys.length > (\"key\" in data.attrs ? 1 : 0);\r\n\t\tmaybeRecreateObject(data, cached, dataAttrKeys);\r\n\t\tif (!isString(data.tag)) return;\r\n\t\tvar isNew = cached.nodes.length === 0;\r\n\t\tnamespace = getObjectNamespace(data, namespace);\r\n\t\tvar node;\r\n\t\tif (isNew) {\r\n\t\t\tnode = constructNode(data, namespace);\r\n\t\t\t//set attributes first, then create children\r\n\t\t\tvar attrs = constructAttrs(data, node, namespace, hasKeys)\r\n\t\t\tvar children = constructChildren(data, node, cached, editable, namespace, configs);\r\n\t\t\tcached = reconstructCached(data, attrs, children, node, namespace, views, controllers);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnode = buildUpdatedNode(cached, data, editable, hasKeys, namespace, views, configs, controllers);\r\n\t\t}\r\n\t\tif (isNew || shouldReattach === true && node != null) insertNode(parentElement, node, index);\r\n\t\t//schedule configs to be called. They are called after `build`\r\n\t\t//finishes running\r\n\t\tscheduleConfigsToBeCalled(configs, data, node, isNew, cached);\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction build(parentElement, parentTag, parentCache, parentIndex, data, cached, shouldReattach, index, editable, namespace, configs) {\r\n\t\t//`build` is a recursive function that manages creation/diffing/removal\r\n\t\t//of DOM elements based on comparison between `data` and `cached`\r\n\t\t//the diff algorithm can be summarized as this:\r\n\t\t//1 - compare `data` and `cached`\r\n\t\t//2 - if they are different, copy `data` to `cached` and update the DOM\r\n\t\t//    based on what the difference is\r\n\t\t//3 - recursively apply this algorithm for every array and for the\r\n\t\t//    children of every virtual element\r\n\r\n\t\t//the `cached` data structure is essentially the same as the previous\r\n\t\t//redraw's `data` data structure, with a few additions:\r\n\t\t//- `cached` always has a property called `nodes`, which is a list of\r\n\t\t//   DOM elements that correspond to the data represented by the\r\n\t\t//   respective virtual element\r\n\t\t//- in order to support attaching `nodes` as a property of `cached`,\r\n\t\t//   `cached` is *always* a non-primitive object, i.e. if the data was\r\n\t\t//   a string, then cached is a String instance. If data was `null` or\r\n\t\t//   `undefined`, cached is `new String(\"\")`\r\n\t\t//- `cached also has a `configContext` property, which is the state\r\n\t\t//   storage object exposed by config(element, isInitialized, context)\r\n\t\t//- when `cached` is an Object, it represents a virtual element; when\r\n\t\t//   it's an Array, it represents a list of elements; when it's a\r\n\t\t//   String, Number or Boolean, it represents a text node\r\n\r\n\t\t//`parentElement` is a DOM element used for W3C DOM API calls\r\n\t\t//`parentTag` is only used for handling a corner case for textarea\r\n\t\t//values\r\n\t\t//`parentCache` is used to remove nodes in some multi-node cases\r\n\t\t//`parentIndex` and `index` are used to figure out the offset of nodes.\r\n\t\t//They're artifacts from before arrays started being flattened and are\r\n\t\t//likely refactorable\r\n\t\t//`data` and `cached` are, respectively, the new and old nodes being\r\n\t\t//diffed\r\n\t\t//`shouldReattach` is a flag indicating whether a parent node was\r\n\t\t//recreated (if so, and if this node is reused, then this node must\r\n\t\t//reattach itself to the new parent)\r\n\t\t//`editable` is a flag that indicates whether an ancestor is\r\n\t\t//contenteditable\r\n\t\t//`namespace` indicates the closest HTML namespace as it cascades down\r\n\t\t//from an ancestor\r\n\t\t//`configs` is a list of config functions to run after the topmost\r\n\t\t//`build` call finishes running\r\n\r\n\t\t//there's logic that relies on the assumption that null and undefined\r\n\t\t//data are equivalent to empty strings\r\n\t\t//- this prevents lifecycle surprises from procedural helpers that mix\r\n\t\t//  implicit and explicit return statements (e.g.\r\n\t\t//  function foo() {if (cond) return m(\"div\")}\r\n\t\t//- it simplifies diffing code\r\n\t\tdata = dataToString(data);\r\n\t\tif (data.subtree === \"retain\") return cached;\r\n\t\tcached = makeCache(data, cached, index, parentIndex, parentCache);\r\n\t\treturn isArray(data) ? buildArray(data, cached, parentElement, index, parentTag, shouldReattach, editable, namespace, configs) :\r\n\t\t\tdata != null && isObject(data) ? buildObject(data, cached, editable, parentElement, index, shouldReattach, namespace, configs) :\r\n\t\t\t!isFunction(data) ? handleText(cached, data, index, parentElement, shouldReattach, editable, parentTag) :\r\n\t\t\tcached;\r\n\t}\r\n\tfunction sortChanges(a, b) { return a.action - b.action || a.index - b.index; }\r\n\tfunction setAttributes(node, tag, dataAttrs, cachedAttrs, namespace) {\r\n\t\tfor (var attrName in dataAttrs) {\r\n\t\t\tvar dataAttr = dataAttrs[attrName];\r\n\t\t\tvar cachedAttr = cachedAttrs[attrName];\r\n\t\t\tif (!(attrName in cachedAttrs) || (cachedAttr !== dataAttr)) {\r\n\t\t\t\tcachedAttrs[attrName] = dataAttr;\r\n\t\t\t\ttry {\r\n\t\t\t\t\t//`config` isn't a real attributes, so ignore it\r\n\t\t\t\t\tif (attrName === \"config\" || attrName === \"key\") continue;\r\n\t\t\t\t\t//hook event handlers to the auto-redrawing system\r\n\t\t\t\t\telse if (isFunction(dataAttr) && attrName.slice(0, 2) === \"on\") {\r\n\t\t\t\t\t\tnode[attrName] = autoredraw(dataAttr, node);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//handle `style: {...}`\r\n\t\t\t\t\telse if (attrName === \"style\" && dataAttr != null && isObject(dataAttr)) {\r\n\t\t\t\t\t\tfor (var rule in dataAttr) {\r\n\t\t\t\t\t\t\tif (cachedAttr == null || cachedAttr[rule] !== dataAttr[rule]) node.style[rule] = dataAttr[rule];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (var rule in cachedAttr) {\r\n\t\t\t\t\t\t\tif (!(rule in dataAttr)) node.style[rule] = \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//handle SVG\r\n\t\t\t\t\telse if (namespace != null) {\r\n\t\t\t\t\t\tif (attrName === \"href\") node.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", dataAttr);\r\n\t\t\t\t\t\telse node.setAttribute(attrName === \"className\" ? \"class\" : attrName, dataAttr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//handle cases that are properties (but ignore cases where we should use setAttribute instead)\r\n\t\t\t\t\t//- list and form are typically used as strings, but are DOM element references in js\r\n\t\t\t\t\t//- when using CSS selectors (e.g. `m(\"[style='']\")`), style is used as a string, but it's an object in js\r\n\t\t\t\t\telse if (attrName in node && attrName !== \"list\" && attrName !== \"style\" && attrName !== \"form\" && attrName !== \"type\" && attrName !== \"width\" && attrName !== \"height\") {\r\n\t\t\t\t\t\t//#348 don't set the value if not needed otherwise cursor placement breaks in Chrome\r\n\t\t\t\t\t\tif (tag !== \"input\" || node[attrName] !== dataAttr) node[attrName] = dataAttr;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse node.setAttribute(attrName, dataAttr);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\t//swallow IE's invalid argument errors to mimic HTML's fallback-to-doing-nothing-on-invalid-attributes behavior\r\n\t\t\t\t\tif (e.message.indexOf(\"Invalid argument\") < 0) throw e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//#348 dataAttr may not be a string, so use loose comparison (double equal) instead of strict (triple equal)\r\n\t\t\telse if (attrName === \"value\" && tag === \"input\" && node.value != dataAttr) {\r\n\t\t\t\tnode.value = dataAttr;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cachedAttrs;\r\n\t}\r\n\tfunction clear(nodes, cached) {\r\n\t\tfor (var i = nodes.length - 1; i > -1; i--) {\r\n\t\t\tif (nodes[i] && nodes[i].parentNode) {\r\n\t\t\t\ttry { nodes[i].parentNode.removeChild(nodes[i]); }\r\n\t\t\t\tcatch (e) {} //ignore if this fails due to order of events (see http://stackoverflow.com/questions/21926083/failed-to-execute-removechild-on-node)\r\n\t\t\t\tcached = [].concat(cached);\r\n\t\t\t\tif (cached[i]) unload(cached[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//release memory if nodes is an array. This check should fail if nodes is a NodeList (see loop above)\r\n\t\tif (nodes.length) nodes.length = 0;\r\n\t}\r\n\tfunction unload(cached) {\r\n\t\tif (cached.configContext && isFunction(cached.configContext.onunload)) {\r\n\t\t\tcached.configContext.onunload();\r\n\t\t\tcached.configContext.onunload = null;\r\n\t\t}\r\n\t\tif (cached.controllers) {\r\n\t\t\tforEach(cached.controllers, function (controller) {\r\n\t\t\t\tif (isFunction(controller.onunload)) controller.onunload({preventDefault: noop});\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (cached.children) {\r\n\t\t\tif (isArray(cached.children)) forEach(cached.children, unload);\r\n\t\t\telse if (cached.children.tag) unload(cached.children);\r\n\t\t}\r\n\t}\r\n\tfunction injectHTML(parentElement, index, data) {\r\n\t\tvar nextSibling = parentElement.childNodes[index];\r\n\t\tif (nextSibling) {\r\n\t\t\tvar isElement = nextSibling.nodeType !== 1;\r\n\t\t\tvar placeholder = $document.createElement(\"span\");\r\n\t\t\tif (isElement) {\r\n\t\t\t\tparentElement.insertBefore(placeholder, nextSibling || null);\r\n\t\t\t\tplaceholder.insertAdjacentHTML(\"beforebegin\", data);\r\n\t\t\t\tparentElement.removeChild(placeholder);\r\n\t\t\t}\r\n\t\t\telse nextSibling.insertAdjacentHTML(\"beforebegin\", data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (window.Range && window.Range.prototype.createContextualFragment) {\r\n\t\t\t\tparentElement.appendChild($document.createRange().createContextualFragment(data));\r\n\t\t\t}\r\n\t\t\telse parentElement.insertAdjacentHTML(\"beforeend\", data);\r\n\t\t}\r\n\t\tvar nodes = [];\r\n\t\twhile (parentElement.childNodes[index] !== nextSibling) {\r\n\t\t\tnodes.push(parentElement.childNodes[index]);\r\n\t\t\tindex++;\r\n\t\t}\r\n\t\treturn nodes;\r\n\t}\r\n\tfunction autoredraw(callback, object) {\r\n\t\treturn function(e) {\r\n\t\t\te = e || event;\r\n\t\t\tm.redraw.strategy(\"diff\");\r\n\t\t\tm.startComputation();\r\n\t\t\ttry { return callback.call(object, e); }\r\n\t\t\tfinally {\r\n\t\t\t\tendFirstComputation();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tvar html;\r\n\tvar documentNode = {\r\n\t\tappendChild: function(node) {\r\n\t\t\tif (html === undefined) html = $document.createElement(\"html\");\r\n\t\t\tif ($document.documentElement && $document.documentElement !== node) {\r\n\t\t\t\t$document.replaceChild(node, $document.documentElement);\r\n\t\t\t}\r\n\t\t\telse $document.appendChild(node);\r\n\t\t\tthis.childNodes = $document.childNodes;\r\n\t\t},\r\n\t\tinsertBefore: function(node) {\r\n\t\t\tthis.appendChild(node);\r\n\t\t},\r\n\t\tchildNodes: []\r\n\t};\r\n\tvar nodeCache = [], cellCache = {};\r\n\tm.render = function(root, cell, forceRecreation) {\r\n\t\tvar configs = [];\r\n\t\tif (!root) throw new Error(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\");\r\n\t\tvar id = getCellCacheKey(root);\r\n\t\tvar isDocumentRoot = root === $document;\r\n\t\tvar node = isDocumentRoot || root === $document.documentElement ? documentNode : root;\r\n\t\tif (isDocumentRoot && cell.tag !== \"html\") cell = {tag: \"html\", attrs: {}, children: cell};\r\n\t\tif (cellCache[id] === undefined) clear(node.childNodes);\r\n\t\tif (forceRecreation === true) reset(root);\r\n\t\tcellCache[id] = build(node, null, undefined, undefined, cell, cellCache[id], false, 0, null, undefined, configs);\r\n\t\tforEach(configs, function (config) { config(); });\r\n\t};\r\n\tfunction getCellCacheKey(element) {\r\n\t\tvar index = nodeCache.indexOf(element);\r\n\t\treturn index < 0 ? nodeCache.push(element) - 1 : index;\r\n\t}\r\n\r\n\tm.trust = function(value) {\r\n\t\tvalue = new String(value);\r\n\t\tvalue.$trusted = true;\r\n\t\treturn value;\r\n\t};\r\n\r\n\tfunction gettersetter(store) {\r\n\t\tvar prop = function() {\r\n\t\t\tif (arguments.length) store = arguments[0];\r\n\t\t\treturn store;\r\n\t\t};\r\n\r\n\t\tprop.toJSON = function() {\r\n\t\t\treturn store;\r\n\t\t};\r\n\r\n\t\treturn prop;\r\n\t}\r\n\r\n\tm.prop = function (store) {\r\n\t\t//note: using non-strict equality check here because we're checking if store is null OR undefined\r\n\t\tif ((store != null && isObject(store) || isFunction(store)) && isFunction(store.then)) {\r\n\t\t\treturn propify(store);\r\n\t\t}\r\n\r\n\t\treturn gettersetter(store);\r\n\t};\r\n\r\n\tvar roots = [], components = [], controllers = [], lastRedrawId = null, lastRedrawCallTime = 0, computePreRedrawHook = null, computePostRedrawHook = null, topComponent, unloaders = [];\r\n\tvar FRAME_BUDGET = 16; //60 frames per second = 1 call per 16 ms\r\n\tfunction parameterize(component, args) {\r\n\t\tvar controller = function() {\r\n\t\t\treturn (component.controller || noop).apply(this, args) || this;\r\n\t\t};\r\n\t\tif (component.controller) controller.prototype = component.controller.prototype;\r\n\t\tvar view = function(ctrl) {\r\n\t\t\tvar currentArgs = arguments.length > 1 ? args.concat([].slice.call(arguments, 1)) : args;\r\n\t\t\treturn component.view.apply(component, currentArgs ? [ctrl].concat(currentArgs) : [ctrl]);\r\n\t\t};\r\n\t\tview.$original = component.view;\r\n\t\tvar output = {controller: controller, view: view};\r\n\t\tif (args[0] && args[0].key != null) output.attrs = {key: args[0].key};\r\n\t\treturn output;\r\n\t}\r\n\tm.component = function(component) {\r\n\t\tfor (var args = [], i = 1; i < arguments.length; i++) args.push(arguments[i]);\r\n\t\treturn parameterize(component, args);\r\n\t};\r\n\tm.mount = m.module = function(root, component) {\r\n\t\tif (!root) throw new Error(\"Please ensure the DOM element exists before rendering a template into it.\");\r\n\t\tvar index = roots.indexOf(root);\r\n\t\tif (index < 0) index = roots.length;\r\n\r\n\t\tvar isPrevented = false;\r\n\t\tvar event = {preventDefault: function() {\r\n\t\t\tisPrevented = true;\r\n\t\t\tcomputePreRedrawHook = computePostRedrawHook = null;\r\n\t\t}};\r\n\r\n\t\tforEach(unloaders, function (unloader) {\r\n\t\t\tunloader.handler.call(unloader.controller, event);\r\n\t\t\tunloader.controller.onunload = null;\r\n\t\t});\r\n\r\n\t\tif (isPrevented) {\r\n\t\t\tforEach(unloaders, function (unloader) {\r\n\t\t\t\tunloader.controller.onunload = unloader.handler;\r\n\t\t\t});\r\n\t\t}\r\n\t\telse unloaders = [];\r\n\r\n\t\tif (controllers[index] && isFunction(controllers[index].onunload)) {\r\n\t\t\tcontrollers[index].onunload(event);\r\n\t\t}\r\n\r\n\t\tvar isNullComponent = component === null;\r\n\r\n\t\tif (!isPrevented) {\r\n\t\t\tm.redraw.strategy(\"all\");\r\n\t\t\tm.startComputation();\r\n\t\t\troots[index] = root;\r\n\t\t\tvar currentComponent = component ? (topComponent = component) : (topComponent = component = {controller: noop});\r\n\t\t\tvar controller = new (component.controller || noop)();\r\n\t\t\t//controllers may call m.mount recursively (via m.route redirects, for example)\r\n\t\t\t//this conditional ensures only the last recursive m.mount call is applied\r\n\t\t\tif (currentComponent === topComponent) {\r\n\t\t\t\tcontrollers[index] = controller;\r\n\t\t\t\tcomponents[index] = component;\r\n\t\t\t}\r\n\t\t\tendFirstComputation();\r\n\t\t\tif (isNullComponent) {\r\n\t\t\t\tremoveRootElement(root, index);\r\n\t\t\t}\r\n\t\t\treturn controllers[index];\r\n\t\t}\r\n\t\tif (isNullComponent) {\r\n\t\t\tremoveRootElement(root, index);\r\n\t\t}\r\n\t};\r\n\r\n\tfunction removeRootElement(root, index) {\r\n\t\troots.splice(index, 1);\r\n\t\tcontrollers.splice(index, 1);\r\n\t\tcomponents.splice(index, 1);\r\n\t\treset(root);\r\n\t\tnodeCache.splice(getCellCacheKey(root), 1);\r\n\t}\r\n\r\n\tvar redrawing = false, forcing = false;\r\n\tm.redraw = function(force) {\r\n\t\tif (redrawing) return;\r\n\t\tredrawing = true;\r\n\t\tif (force) forcing = true;\r\n\t\ttry {\r\n\t\t\t//lastRedrawId is a positive number if a second redraw is requested before the next animation frame\r\n\t\t\t//lastRedrawID is null if it's the first redraw and not an event handler\r\n\t\t\tif (lastRedrawId && !force) {\r\n\t\t\t\t//when setTimeout: only reschedule redraw if time between now and previous redraw is bigger than a frame, otherwise keep currently scheduled timeout\r\n\t\t\t\t//when rAF: always reschedule redraw\r\n\t\t\t\tif ($requestAnimationFrame === window.requestAnimationFrame || new Date - lastRedrawCallTime > FRAME_BUDGET) {\r\n\t\t\t\t\tif (lastRedrawId > 0) $cancelAnimationFrame(lastRedrawId);\r\n\t\t\t\t\tlastRedrawId = $requestAnimationFrame(redraw, FRAME_BUDGET);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tredraw();\r\n\t\t\t\tlastRedrawId = $requestAnimationFrame(function() { lastRedrawId = null; }, FRAME_BUDGET);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tredrawing = forcing = false;\r\n\t\t}\r\n\t};\r\n\tm.redraw.strategy = m.prop();\r\n\tfunction redraw() {\r\n\t\tif (computePreRedrawHook) {\r\n\t\t\tcomputePreRedrawHook();\r\n\t\t\tcomputePreRedrawHook = null;\r\n\t\t}\r\n\t\tforEach(roots, function (root, i) {\r\n\t\t\tvar component = components[i];\r\n\t\t\tif (controllers[i]) {\r\n\t\t\t\tvar args = [controllers[i]];\r\n\t\t\t\tm.render(root, component.view ? component.view(controllers[i], args) : \"\");\r\n\t\t\t}\r\n\t\t});\r\n\t\t//after rendering within a routed context, we need to scroll back to the top, and fetch the document title for history.pushState\r\n\t\tif (computePostRedrawHook) {\r\n\t\t\tcomputePostRedrawHook();\r\n\t\t\tcomputePostRedrawHook = null;\r\n\t\t}\r\n\t\tlastRedrawId = null;\r\n\t\tlastRedrawCallTime = new Date;\r\n\t\tm.redraw.strategy(\"diff\");\r\n\t}\r\n\r\n\tvar pendingRequests = 0;\r\n\tm.startComputation = function() { pendingRequests++; };\r\n\tm.endComputation = function() {\r\n\t\tif (pendingRequests > 1) pendingRequests--;\r\n\t\telse {\r\n\t\t\tpendingRequests = 0;\r\n\t\t\tm.redraw();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction endFirstComputation() {\r\n\t\tif (m.redraw.strategy() === \"none\") {\r\n\t\t\tpendingRequests--;\r\n\t\t\tm.redraw.strategy(\"diff\");\r\n\t\t}\r\n\t\telse m.endComputation();\r\n\t}\r\n\r\n\tm.withAttr = function(prop, withAttrCallback, callbackThis) {\r\n\t\treturn function(e) {\r\n\t\t\te = e || event;\r\n\t\t\tvar currentTarget = e.currentTarget || this;\r\n\t\t\tvar _this = callbackThis || this;\r\n\t\t\twithAttrCallback.call(_this, prop in currentTarget ? currentTarget[prop] : currentTarget.getAttribute(prop));\r\n\t\t};\r\n\t};\r\n\r\n\t//routing\r\n\tvar modes = {pathname: \"\", hash: \"#\", search: \"?\"};\r\n\tvar redirect = noop, routeParams, currentRoute, isDefaultRoute = false;\r\n\tm.route = function(root, arg1, arg2, vdom) {\r\n\t\t//m.route()\r\n\t\tif (arguments.length === 0) return currentRoute;\r\n\t\t//m.route(el, defaultRoute, routes)\r\n\t\telse if (arguments.length === 3 && isString(arg1)) {\r\n\t\t\tredirect = function(source) {\r\n\t\t\t\tvar path = currentRoute = normalizeRoute(source);\r\n\t\t\t\tif (!routeByValue(root, arg2, path)) {\r\n\t\t\t\t\tif (isDefaultRoute) throw new Error(\"Ensure the default route matches one of the routes defined in m.route\");\r\n\t\t\t\t\tisDefaultRoute = true;\r\n\t\t\t\t\tm.route(arg1, true);\r\n\t\t\t\t\tisDefaultRoute = false;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tvar listener = m.route.mode === \"hash\" ? \"onhashchange\" : \"onpopstate\";\r\n\t\t\twindow[listener] = function() {\r\n\t\t\t\tvar path = $location[m.route.mode];\r\n\t\t\t\tif (m.route.mode === \"pathname\") path += $location.search;\r\n\t\t\t\tif (currentRoute !== normalizeRoute(path)) redirect(path);\r\n\t\t\t};\r\n\r\n\t\t\tcomputePreRedrawHook = setScroll;\r\n\t\t\twindow[listener]();\r\n\t\t}\r\n\t\t//config: m.route\r\n\t\telse if (root.addEventListener || root.attachEvent) {\r\n\t\t\troot.href = (m.route.mode !== 'pathname' ? $location.pathname : '') + modes[m.route.mode] + vdom.attrs.href;\r\n\t\t\tif (root.addEventListener) {\r\n\t\t\t\troot.removeEventListener(\"click\", routeUnobtrusive);\r\n\t\t\t\troot.addEventListener(\"click\", routeUnobtrusive);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\troot.detachEvent(\"onclick\", routeUnobtrusive);\r\n\t\t\t\troot.attachEvent(\"onclick\", routeUnobtrusive);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//m.route(route, params, shouldReplaceHistoryEntry)\r\n\t\telse if (isString(root)) {\r\n\t\t\tvar oldRoute = currentRoute;\r\n\t\t\tcurrentRoute = root;\r\n\t\t\tvar args = arg1 || {};\r\n\t\t\tvar queryIndex = currentRoute.indexOf(\"?\");\r\n\t\t\tvar params = queryIndex > -1 ? parseQueryString(currentRoute.slice(queryIndex + 1)) : {};\r\n\t\t\tfor (var i in args) params[i] = args[i];\r\n\t\t\tvar querystring = buildQueryString(params);\r\n\t\t\tvar currentPath = queryIndex > -1 ? currentRoute.slice(0, queryIndex) : currentRoute;\r\n\t\t\tif (querystring) currentRoute = currentPath + (currentPath.indexOf(\"?\") === -1 ? \"?\" : \"&\") + querystring;\r\n\r\n\t\t\tvar shouldReplaceHistoryEntry = (arguments.length === 3 ? arg2 : arg1) === true || oldRoute === root;\r\n\r\n\t\t\tif (window.history.pushState) {\r\n\t\t\t\tcomputePreRedrawHook = setScroll;\r\n\t\t\t\tcomputePostRedrawHook = function() {\r\n\t\t\t\t\twindow.history[shouldReplaceHistoryEntry ? \"replaceState\" : \"pushState\"](null, $document.title, modes[m.route.mode] + currentRoute);\r\n\t\t\t\t};\r\n\t\t\t\tredirect(modes[m.route.mode] + currentRoute);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$location[m.route.mode] = currentRoute;\r\n\t\t\t\tredirect(modes[m.route.mode] + currentRoute);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tm.route.param = function(key) {\r\n\t\tif (!routeParams) throw new Error(\"You must call m.route(element, defaultRoute, routes) before calling m.route.param()\");\r\n\t\tif( !key ){\r\n\t\t\treturn routeParams;\r\n\t\t}\r\n\t\treturn routeParams[key];\r\n\t};\r\n\tm.route.mode = \"search\";\r\n\tfunction normalizeRoute(route) {\r\n\t\treturn route.slice(modes[m.route.mode].length);\r\n\t}\r\n\tfunction routeByValue(root, router, path) {\r\n\t\trouteParams = {};\r\n\r\n\t\tvar queryStart = path.indexOf(\"?\");\r\n\t\tif (queryStart !== -1) {\r\n\t\t\trouteParams = parseQueryString(path.substr(queryStart + 1, path.length));\r\n\t\t\tpath = path.substr(0, queryStart);\r\n\t\t}\r\n\r\n\t\t// Get all routes and check if there's\r\n\t\t// an exact match for the current path\r\n\t\tvar keys = Object.keys(router);\r\n\t\tvar index = keys.indexOf(path);\r\n\t\tif(index !== -1){\r\n\t\t\tm.mount(root, router[keys [index]]);\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tfor (var route in router) {\r\n\t\t\tif (route === path) {\r\n\t\t\t\tm.mount(root, router[route]);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tvar matcher = new RegExp(\"^\" + route.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\").replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\");\r\n\r\n\t\t\tif (matcher.test(path)) {\r\n\t\t\t\tpath.replace(matcher, function() {\r\n\t\t\t\t\tvar keys = route.match(/:[^\\/]+/g) || [];\r\n\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2);\r\n\t\t\t\t\tforEach(keys, function (key, i) {\r\n\t\t\t\t\t\trouteParams[key.replace(/:|\\./g, \"\")] = decodeURIComponent(values[i]);\r\n\t\t\t\t\t})\r\n\t\t\t\t\tm.mount(root, router[route]);\r\n\t\t\t\t});\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction routeUnobtrusive(e) {\r\n\t\te = e || event;\r\n\r\n\t\tif (e.ctrlKey || e.metaKey || e.which === 2) return;\r\n\r\n\t\tif (e.preventDefault) e.preventDefault();\r\n\t\telse e.returnValue = false;\r\n\r\n\t\tvar currentTarget = e.currentTarget || e.srcElement;\r\n\t\tvar args = m.route.mode === \"pathname\" && currentTarget.search ? parseQueryString(currentTarget.search.slice(1)) : {};\r\n\t\twhile (currentTarget && currentTarget.nodeName.toUpperCase() !== \"A\") currentTarget = currentTarget.parentNode;\r\n\t\t// clear pendingRequests because we want an immediate route change\r\n\t\tpendingRequests = 0;\r\n\t\tm.route(currentTarget[m.route.mode].slice(modes[m.route.mode].length), args);\r\n\t}\r\n\tfunction setScroll() {\r\n\t\tif (m.route.mode !== \"hash\" && $location.hash) $location.hash = $location.hash;\r\n\t\telse window.scrollTo(0, 0);\r\n\t}\r\n\tfunction buildQueryString(object, prefix) {\r\n\t\tvar duplicates = {};\r\n\t\tvar str = [];\r\n\t\tfor (var prop in object) {\r\n\t\t\tvar key = prefix ? prefix + \"[\" + prop + \"]\" : prop;\r\n\t\t\tvar value = object[prop];\r\n\r\n\t\t\tif (value === null) {\r\n\t\t\t\tstr.push(encodeURIComponent(key));\r\n\t\t\t} else if (isObject(value)) {\r\n\t\t\t\tstr.push(buildQueryString(value, key));\r\n\t\t\t} else if (isArray(value)) {\r\n\t\t\t\tvar keys = [];\r\n\t\t\t\tduplicates[key] = duplicates[key] || {};\r\n\t\t\t\tforEach(value, function (item) {\r\n\t\t\t\t\tif (!duplicates[key][item]) {\r\n\t\t\t\t\t\tduplicates[key][item] = true;\r\n\t\t\t\t\t\tkeys.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(item));\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tstr.push(keys.join(\"&\"));\r\n\t\t\t} else if (value !== undefined) {\r\n\t\t\t\tstr.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str.join(\"&\");\r\n\t}\r\n\tfunction parseQueryString(str) {\r\n\t\tif (str === \"\" || str == null) return {};\r\n\t\tif (str.charAt(0) === \"?\") str = str.slice(1);\r\n\r\n\t\tvar pairs = str.split(\"&\"), params = {};\r\n\t\tforEach(pairs, function (string) {\r\n\t\t\tvar pair = string.split(\"=\");\r\n\t\t\tvar key = decodeURIComponent(pair[0]);\r\n\t\t\tvar value = pair.length === 2 ? decodeURIComponent(pair[1]) : null;\r\n\t\t\tif (params[key] != null) {\r\n\t\t\t\tif (!isArray(params[key])) params[key] = [params[key]];\r\n\t\t\t\tparams[key].push(value);\r\n\t\t\t}\r\n\t\t\telse params[key] = value;\r\n\t\t});\r\n\r\n\t\treturn params;\r\n\t}\r\n\tm.route.buildQueryString = buildQueryString;\r\n\tm.route.parseQueryString = parseQueryString;\r\n\r\n\tfunction reset(root) {\r\n\t\tvar cacheKey = getCellCacheKey(root);\r\n\t\tclear(root.childNodes, cellCache[cacheKey]);\r\n\t\tcellCache[cacheKey] = undefined;\r\n\t}\r\n\r\n\tm.deferred = function () {\r\n\t\tvar deferred = new Deferred();\r\n\t\tdeferred.promise = propify(deferred.promise);\r\n\t\treturn deferred;\r\n\t};\r\n\tfunction propify(promise, initialValue) {\r\n\t\tvar prop = m.prop(initialValue);\r\n\t\tpromise.then(prop);\r\n\t\tprop.then = function(resolve, reject) {\r\n\t\t\treturn propify(promise.then(resolve, reject), initialValue);\r\n\t\t};\r\n\t\tprop[\"catch\"] = prop.then.bind(null, null);\r\n\t\treturn prop;\r\n\t}\r\n\t//Promiz.mithril.js | Zolmeister | MIT\r\n\t//a modified version of Promiz.js, which does not conform to Promises/A+ for two reasons:\r\n\t//1) `then` callbacks are called synchronously (because setTimeout is too slow, and the setImmediate polyfill is too big\r\n\t//2) throwing subclasses of Error cause the error to be bubbled up instead of triggering rejection (because the spec does not account for the important use case of default browser error handling, i.e. message w/ line number)\r\n\tfunction Deferred(successCallback, failureCallback) {\r\n\t\tvar RESOLVING = 1, REJECTING = 2, RESOLVED = 3, REJECTED = 4;\r\n\t\tvar self = this, state = 0, promiseValue = 0, next = [];\r\n\r\n\t\tself.promise = {};\r\n\r\n\t\tself.resolve = function(value) {\r\n\t\t\tif (!state) {\r\n\t\t\t\tpromiseValue = value;\r\n\t\t\t\tstate = RESOLVING;\r\n\r\n\t\t\t\tfire();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t};\r\n\r\n\t\tself.reject = function(value) {\r\n\t\t\tif (!state) {\r\n\t\t\t\tpromiseValue = value;\r\n\t\t\t\tstate = REJECTING;\r\n\r\n\t\t\t\tfire();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t};\r\n\r\n\t\tself.promise.then = function(successCallback, failureCallback) {\r\n\t\t\tvar deferred = new Deferred(successCallback, failureCallback)\r\n\t\t\tif (state === RESOLVED) {\r\n\t\t\t\tdeferred.resolve(promiseValue);\r\n\t\t\t}\r\n\t\t\telse if (state === REJECTED) {\r\n\t\t\t\tdeferred.reject(promiseValue);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tnext.push(deferred);\r\n\t\t\t}\r\n\t\t\treturn deferred.promise\r\n\t\t};\r\n\r\n\t\tfunction finish(type) {\r\n\t\t\tstate = type || REJECTED;\r\n\t\t\tnext.map(function(deferred) {\r\n\t\t\t\tstate === RESOLVED ? deferred.resolve(promiseValue) : deferred.reject(promiseValue);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction thennable(then, successCallback, failureCallback, notThennableCallback) {\r\n\t\t\tif (((promiseValue != null && isObject(promiseValue)) || isFunction(promiseValue)) && isFunction(then)) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// count protects against abuse calls from spec checker\r\n\t\t\t\t\tvar count = 0;\r\n\t\t\t\t\tthen.call(promiseValue, function(value) {\r\n\t\t\t\t\t\tif (count++) return;\r\n\t\t\t\t\t\tpromiseValue = value;\r\n\t\t\t\t\t\tsuccessCallback();\r\n\t\t\t\t\t}, function (value) {\r\n\t\t\t\t\t\tif (count++) return;\r\n\t\t\t\t\t\tpromiseValue = value;\r\n\t\t\t\t\t\tfailureCallback();\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tm.deferred.onerror(e);\r\n\t\t\t\t\tpromiseValue = e;\r\n\t\t\t\t\tfailureCallback();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnotThennableCallback();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction fire() {\r\n\t\t\t// check if it's a thenable\r\n\t\t\tvar then;\r\n\t\t\ttry {\r\n\t\t\t\tthen = promiseValue && promiseValue.then;\r\n\t\t\t}\r\n\t\t\tcatch (e) {\r\n\t\t\t\tm.deferred.onerror(e);\r\n\t\t\t\tpromiseValue = e;\r\n\t\t\t\tstate = REJECTING;\r\n\t\t\t\treturn fire();\r\n\t\t\t}\r\n\r\n\t\t\tif (state === REJECTING) {\r\n\t\t\t\tm.deferred.onerror(promiseValue)\r\n\t\t\t}\r\n\r\n\t\t\tthennable(then, function () {\r\n\t\t\t\tstate = RESOLVING\r\n\t\t\t\tfire()\r\n\t\t\t}, function () {\r\n\t\t\t\tstate = REJECTING\r\n\t\t\t\tfire()\r\n\t\t\t}, function () {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (state === RESOLVING && isFunction(successCallback)) {\r\n\t\t\t\t\t\tpromiseValue = successCallback(promiseValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (state === REJECTING && isFunction(failureCallback)) {\r\n\t\t\t\t\t\tpromiseValue = failureCallback(promiseValue);\r\n\t\t\t\t\t\tstate = RESOLVING;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tm.deferred.onerror(e);\r\n\t\t\t\t\tpromiseValue = e;\r\n\t\t\t\t\treturn finish();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (promiseValue === self) {\r\n\t\t\t\t\tpromiseValue = TypeError();\r\n\t\t\t\t\tfinish();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthennable(then, function () {\r\n\t\t\t\t\t\tfinish(RESOLVED);\r\n\t\t\t\t\t}, finish, function () {\r\n\t\t\t\t\t\tfinish(state === RESOLVING && RESOLVED);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\tm.deferred.onerror = function(e) {\r\n\t\tif (type.call(e) === \"[object Error]\" && !e.constructor.toString().match(/ Error/)) {\r\n\t\t\tpendingRequests = 0;\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t};\r\n\r\n\tm.sync = function(args) {\r\n\t\tvar method = \"resolve\";\r\n\r\n\t\tfunction synchronizer(pos, resolved) {\r\n\t\t\treturn function(value) {\r\n\t\t\t\tresults[pos] = value;\r\n\t\t\t\tif (!resolved) method = \"reject\";\r\n\t\t\t\tif (--outstanding === 0) {\r\n\t\t\t\t\tdeferred.promise(results);\r\n\t\t\t\t\tdeferred[method](results);\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar deferred = m.deferred();\r\n\t\tvar outstanding = args.length;\r\n\t\tvar results = new Array(outstanding);\r\n\t\tif (args.length > 0) {\r\n\t\t\tforEach(args, function (arg, i) {\r\n\t\t\t\targ.then(synchronizer(i, true), synchronizer(i, false));\r\n\t\t\t});\r\n\t\t}\r\n\t\telse deferred.resolve([]);\r\n\r\n\t\treturn deferred.promise;\r\n\t};\r\n\tfunction identity(value) { return value; }\r\n\r\n\tfunction ajax(options) {\r\n\t\tif (options.dataType && options.dataType.toLowerCase() === \"jsonp\") {\r\n\t\t\tvar callbackKey = \"mithril_callback_\" + new Date().getTime() + \"_\" + (Math.round(Math.random() * 1e16)).toString(36)\r\n\t\t\tvar script = $document.createElement(\"script\");\r\n\r\n\t\t\twindow[callbackKey] = function(resp) {\r\n\t\t\t\tscript.parentNode.removeChild(script);\r\n\t\t\t\toptions.onload({\r\n\t\t\t\t\ttype: \"load\",\r\n\t\t\t\t\ttarget: {\r\n\t\t\t\t\t\tresponseText: resp\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\twindow[callbackKey] = undefined;\r\n\t\t\t};\r\n\r\n\t\t\tscript.onerror = function() {\r\n\t\t\t\tscript.parentNode.removeChild(script);\r\n\r\n\t\t\t\toptions.onerror({\r\n\t\t\t\t\ttype: \"error\",\r\n\t\t\t\t\ttarget: {\r\n\t\t\t\t\t\tstatus: 500,\r\n\t\t\t\t\t\tresponseText: JSON.stringify({\r\n\t\t\t\t\t\t\terror: \"Error making jsonp request\"\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\twindow[callbackKey] = undefined;\r\n\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tscript.onload = function() {\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\r\n\t\t\tscript.src = options.url\r\n\t\t\t\t+ (options.url.indexOf(\"?\") > 0 ? \"&\" : \"?\")\r\n\t\t\t\t+ (options.callbackKey ? options.callbackKey : \"callback\")\r\n\t\t\t\t+ \"=\" + callbackKey\r\n\t\t\t\t+ \"&\" + buildQueryString(options.data || {});\r\n\t\t\t$document.body.appendChild(script);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvar xhr = new window.XMLHttpRequest();\r\n\t\t\txhr.open(options.method, options.url, true, options.user, options.password);\r\n\t\t\txhr.onreadystatechange = function() {\r\n\t\t\t\tif (xhr.readyState === 4) {\r\n\t\t\t\t\tif (xhr.status >= 200 && xhr.status < 300) options.onload({type: \"load\", target: xhr});\r\n\t\t\t\t\telse options.onerror({type: \"error\", target: xhr});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tif (options.serialize === JSON.stringify && options.data && options.method !== \"GET\") {\r\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\");\r\n\t\t\t}\r\n\t\t\tif (options.deserialize === JSON.parse) {\r\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\");\r\n\t\t\t}\r\n\t\t\tif (isFunction(options.config)) {\r\n\t\t\t\tvar maybeXhr = options.config(xhr, options);\r\n\t\t\t\tif (maybeXhr != null) xhr = maybeXhr;\r\n\t\t\t}\r\n\r\n\t\t\tvar data = options.method === \"GET\" || !options.data ? \"\" : options.data;\r\n\t\t\tif (data && (!isString(data) && data.constructor !== window.FormData)) {\r\n\t\t\t\tthrow new Error(\"Request data should be either be a string or FormData. Check the `serialize` option in `m.request`\");\r\n\t\t\t}\r\n\t\t\txhr.send(data);\r\n\t\t\treturn xhr;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindData(xhrOptions, data, serialize) {\r\n\t\tif (xhrOptions.method === \"GET\" && xhrOptions.dataType !== \"jsonp\") {\r\n\t\t\tvar prefix = xhrOptions.url.indexOf(\"?\") < 0 ? \"?\" : \"&\";\r\n\t\t\tvar querystring = buildQueryString(data);\r\n\t\t\txhrOptions.url = xhrOptions.url + (querystring ? prefix + querystring : \"\");\r\n\t\t}\r\n\t\telse xhrOptions.data = serialize(data);\r\n\t\treturn xhrOptions;\r\n\t}\r\n\r\n\tfunction parameterizeUrl(url, data) {\r\n\t\tvar tokens = url.match(/:[a-z]\\w+/gi);\r\n\t\tif (tokens && data) {\r\n\t\t\tforEach(tokens, function (token) {\r\n\t\t\t\tvar key = token.slice(1);\r\n\t\t\t\turl = url.replace(token, data[key]);\r\n\t\t\t\tdelete data[key];\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn url;\r\n\t}\r\n\r\n\tm.request = function(xhrOptions) {\r\n\t\tif (xhrOptions.background !== true) m.startComputation();\r\n\t\tvar deferred = new Deferred();\r\n\t\tvar isJSONP = xhrOptions.dataType && xhrOptions.dataType.toLowerCase() === \"jsonp\"\r\n\t\tvar serialize = xhrOptions.serialize = isJSONP ? identity : xhrOptions.serialize || JSON.stringify;\r\n\t\tvar deserialize = xhrOptions.deserialize = isJSONP ? identity : xhrOptions.deserialize || JSON.parse;\r\n\t\tvar extract = isJSONP ? function(jsonp) { return jsonp.responseText } : xhrOptions.extract || function(xhr) {\r\n\t\t\tif (xhr.responseText.length === 0 && deserialize === JSON.parse) {\r\n\t\t\t\treturn null\r\n\t\t\t} else {\r\n\t\t\t\treturn xhr.responseText\r\n\t\t\t}\r\n\t\t};\r\n\t\txhrOptions.method = (xhrOptions.method || \"GET\").toUpperCase();\r\n\t\txhrOptions.url = parameterizeUrl(xhrOptions.url, xhrOptions.data);\r\n\t\txhrOptions = bindData(xhrOptions, xhrOptions.data, serialize);\r\n\t\txhrOptions.onload = xhrOptions.onerror = function(e) {\r\n\t\t\ttry {\r\n\t\t\t\te = e || event;\r\n\t\t\t\tvar unwrap = (e.type === \"load\" ? xhrOptions.unwrapSuccess : xhrOptions.unwrapError) || identity;\r\n\t\t\t\tvar response = unwrap(deserialize(extract(e.target, xhrOptions)), e.target);\r\n\t\t\t\tif (e.type === \"load\") {\r\n\t\t\t\t\tif (isArray(response) && xhrOptions.type) {\r\n\t\t\t\t\t\tforEach(response, function (res, i) {\r\n\t\t\t\t\t\t\tresponse[i] = new xhrOptions.type(res);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else if (xhrOptions.type) {\r\n\t\t\t\t\t\tresponse = new xhrOptions.type(response);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdeferred.resolve(response)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdeferred.reject(response)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdeferred[e.type === \"load\" ? \"resolve\" : \"reject\"](response);\r\n\t\t\t}\r\n\t\t\tcatch (e) {\r\n\t\t\t\tdeferred.reject(e);\r\n\t\t\t}\r\n\t\t\tfinally {\r\n\t\t\t\tif (xhrOptions.background !== true) m.endComputation()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tajax(xhrOptions);\r\n\t\tdeferred.promise = propify(deferred.promise, xhrOptions.initialValue);\r\n\t\treturn deferred.promise;\r\n\t};\r\n\r\n\t//testing API\r\n\tm.deps = function(mock) {\r\n\t\tinitialize(window = mock || window);\r\n\t\treturn window;\r\n\t};\r\n\t//for internal testing only, do not use `m.deps.factory`\r\n\tm.deps.factory = app;\r\n\r\n\treturn m;\r\n})(typeof window !== \"undefined\" ? window : {});\r\n\r\nif (typeof module === \"object\" && module != null && module.exports) module.exports = m;\r\nelse if (typeof define === \"function\" && define.amd) define(function() { return m });\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mithril/mithril.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\n\n/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  root = this;\n}\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pushEncodedKeyValuePair(pairs, key, obj[key]);\n        }\n      }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (Array.isArray(val)) {\n    return val.forEach(function(v) {\n      pushEncodedKeyValuePair(pairs, key, v);\n    });\n  }\n  pairs.push(encodeURIComponent(key)\n    + '=' + encodeURIComponent(val));\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  return /[\\/+]json\\b/.test(mime);\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = request.parse[this.type];\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = this.statusCode = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  Emitter.call(this);\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {};\n  this._header = {};\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    if (err) {\n      return self.callback(err, res);\n    }\n\n    if (res.status >= 200 && res.status < 300) {\n      return self.callback(err, res);\n    }\n\n    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n    new_err.original = err;\n    new_err.response = res;\n    new_err.status = res.status;\n\n    self.callback(new_err, res);\n  });\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Allow for extension\n */\n\nRequest.prototype.use = function(fn) {\n  fn(this);\n  return this;\n}\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.timeout = function(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.clearTimeout = function(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Get case-insensitive header `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api private\n */\n\nRequest.prototype.getHeader = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Force given parser\n *\n * Sets the body parser no matter type.\n *\n * @param {Function}\n * @api public\n */\n\nRequest.prototype.parse = function(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass){\n  var str = btoa(user + ':' + pass);\n  this.set('Authorization', 'Basic ' + str);\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.field = function(name, val){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(name, val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(field, file, filename);\n  return this;\n};\n\n/**\n * Send `data`, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // querystring\n *       request.get('/search')\n *         .end(callback)\n *\n *       // multiple data \"writes\"\n *       request.get('/search')\n *         .send({ search: 'query' })\n *         .send({ range: '1..5' })\n *         .send({ order: 'desc' })\n *         .end(callback)\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this.getHeader('Content-Type');\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this.getHeader('Content-Type');\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || isHost(data)) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self.timeoutError();\n      if (self.aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(e){\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    xhr.onprogress = handleProgress;\n  }\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = handleProgress;\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  xhr.open(this.method, this.url, true);\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var contentType = this.getHeader('Content-Type');\n    var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\n/**\n * Faux promise support\n *\n * @param {Function} fulfill\n * @param {Function} reject\n * @return {Request}\n */\n\nRequest.prototype.then = function (fulfill, reject) {\n  return this.end(function(err, res) {\n    err ? reject(err) : fulfill(res);\n  });\n}\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new Request('GET', method);\n  }\n\n  return new Request(method, url);\n}\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nfunction del(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\nrequest.del = del;\nrequest.delete = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * Expose `request`.\n */\n\nmodule.exports = request;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/lib/client.js\n ** module id = 3\n ** module chunks = 0\n **/","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/component-emitter/index.js\n ** module id = 4\n ** module chunks = 0\n **/","\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reduce-component/index.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}