{"version":3,"sources":["webpack:///webpack/bootstrap a7fa47177b5596c5ca5f","webpack:///./src/index.js","webpack:///./~/mithril/mithril.js","webpack:///(webpack)/buildin/module.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACtCA,KAAM,CAAC,GAAG,mBAAO,CAAC,CAAS,CAAC,CAAC;AAC7B,KAAI,GAAG,GAAG,EAAE,CAAC;AACb,IAAG,CAAC,UAAU,GAAG,YAAM;AACrB,UAAO;AACL,OAAE,gBAAG;AACH,YAAK,CAAC,MAAM,CAAC;MACd;IACF;EACF;;AAED,IAAG,CAAC,IAAI,GAAG,UAAC,IAAI,EAAK;AACnB,UAAO,CAAC,CAAC,KAAK,EAAC,EAAC,OAAO,EAAE,IAAI,CAAC,EAAE,EAAC,EAAC,OAAO,CAAC;EAC3C;;AAED,EAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC,C;;;;;;mCCd5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA,aAAY,IAAI;AAChB,aAAY,UAAU;AACtB,aAAY,YAAY;AACxB;AACA;AACA;AACA,6BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,aAAa;AAChB;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,IAAI;AACR,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,2BAA2B;AACxC;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,qBAAqB;AACtE,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA,qCAAoC;AACpC,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,SAAS;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gEAA+D;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,sFAAqF,wBAAwB,IAAI;AACjH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAmD,qDAAqD;AACxG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yIAAwI;AACxI;AACA,kDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAkE;AAClE,wDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,iDAAiD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA,UAAS,2CAA2C;AACpD,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA8D,qBAAqB;AACnF,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,iCAAiC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA,uCAAsC,UAAU,EAAE;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,uDAAsD;AACtD;AACA;AACA;AACA,6BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iGAAgG,iBAAiB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD,qBAAqB,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6DAA4D,EAAE;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA,4BAA2B,cAAc;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE,0BAA0B;AAC1F,4BAA2B,2BAA2B;AACtD;AACA;AACA;AACA,4DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,4BAA4B;AACvE;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,OAAM;AACN;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC,6CAA6C;;AAE9C;AACA,8DAAwE,WAAW;;;;;;;;ACv3CnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../build/app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a7fa47177b5596c5ca5f\n **/","const m = require(\"mithril\");\nlet app = {};\napp.controller = () => {\n  return {\n    al() {\n      alert(\"hoge\")\n    }\n  }\n}\n\napp.view = (ctrl) => {\n  return m(\"div\",{onclick: ctrl.al},\"hello\")\n}\n\nm.mount(document.getElementById(\"app\"), app);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","var m = (function app(window, undefined) {\r\n\t\"use strict\";\r\n  \tvar VERSION = \"v0.2.2-rc.1\";\r\n\tfunction isFunction(object) {\r\n\t\treturn typeof object === \"function\";\r\n\t}\r\n\tfunction isObject(object) {\r\n\t\treturn type.call(object) === \"[object Object]\";\r\n\t}\r\n\tfunction isString(object) {\r\n\t\treturn type.call(object) === \"[object String]\";\r\n\t}\r\n\tvar isArray = Array.isArray || function (object) {\r\n\t\treturn type.call(object) === \"[object Array]\";\r\n\t};\r\n\tvar type = {}.toString;\r\n\tvar parser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[.+?\\])/g, attrParser = /\\[(.+?)(?:=(\"|'|)(.*?)\\2)?\\]/;\r\n\tvar voidElements = /^(AREA|BASE|BR|COL|COMMAND|EMBED|HR|IMG|INPUT|KEYGEN|LINK|META|PARAM|SOURCE|TRACK|WBR)$/;\r\n\tvar noop = function () {};\r\n\r\n\t// caching commonly used variables\r\n\tvar $document, $location, $requestAnimationFrame, $cancelAnimationFrame;\r\n\r\n\t// self invoking function needed because of the way mocks work\r\n\tfunction initialize(window) {\r\n\t\t$document = window.document;\r\n\t\t$location = window.location;\r\n\t\t$cancelAnimationFrame = window.cancelAnimationFrame || window.clearTimeout;\r\n\t\t$requestAnimationFrame = window.requestAnimationFrame || window.setTimeout;\r\n\t}\r\n\r\n\tinitialize(window);\r\n\r\n\tm.version = function() {\r\n\t\treturn VERSION;\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {String} Tag\r\n\t * A string that looks like -> div.classname#id[param=one][param2=two]\r\n\t * Which describes a DOM node\r\n\t */\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Tag} The DOM node tag\r\n\t * @param {Object=[]} optional key-value pairs to be mapped to DOM attrs\r\n\t * @param {...mNode=[]} Zero or more Mithril child nodes. Can be an array, or splat (optional)\r\n\t *\r\n\t */\r\n\tfunction m(tag, pairs) {\r\n\t\tfor (var args = [], i = 1; i < arguments.length; i++) {\r\n\t\t\targs[i - 1] = arguments[i];\r\n\t\t}\r\n\t\tif (isObject(tag)) return parameterize(tag, args);\r\n\t\tvar hasAttrs = pairs != null && isObject(pairs) && !(\"tag\" in pairs || \"view\" in pairs || \"subtree\" in pairs);\r\n\t\tvar attrs = hasAttrs ? pairs : {};\r\n\t\tvar classAttrName = \"class\" in attrs ? \"class\" : \"className\";\r\n\t\tvar cell = {tag: \"div\", attrs: {}};\r\n\t\tvar match, classes = [];\r\n\t\tif (!isString(tag)) throw new Error(\"selector in m(selector, attrs, children) should be a string\");\r\n\t\twhile ((match = parser.exec(tag)) != null) {\r\n\t\t\tif (match[1] === \"\" && match[2]) cell.tag = match[2];\r\n\t\t\telse if (match[1] === \"#\") cell.attrs.id = match[2];\r\n\t\t\telse if (match[1] === \".\") classes.push(match[2]);\r\n\t\t\telse if (match[3][0] === \"[\") {\r\n\t\t\t\tvar pair = attrParser.exec(match[3]);\r\n\t\t\t\tcell.attrs[pair[1]] = pair[3] || (pair[2] ? \"\" :true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar children = hasAttrs ? args.slice(1) : args;\r\n\t\tif (children.length === 1 && isArray(children[0])) {\r\n\t\t\tcell.children = children[0];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcell.children = children;\r\n\t\t}\r\n\r\n\t\tfor (var attrName in attrs) {\r\n\t\t\tif (attrs.hasOwnProperty(attrName)) {\r\n\t\t\t\tif (attrName === classAttrName && attrs[attrName] != null && attrs[attrName] !== \"\") {\r\n\t\t\t\t\tclasses.push(attrs[attrName]);\r\n\t\t\t\t\tcell.attrs[attrName] = \"\"; //create key in correct iteration order\r\n\t\t\t\t}\r\n\t\t\t\telse cell.attrs[attrName] = attrs[attrName];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (classes.length) cell.attrs[classAttrName] = classes.join(\" \");\r\n\r\n\t\treturn cell;\r\n\t}\r\n\tfunction forEach(list, f) {\r\n\t\tfor (var i = 0; i < list.length && !f(list[i], i++);) {}\r\n\t}\r\n\tfunction forKeys(list, f) {\r\n\t\tforEach(list, function (attrs, i) {\r\n\t\t\treturn (attrs = attrs && attrs.attrs) && attrs.key != null && f(attrs, i);\r\n\t\t});\r\n\t}\r\n\t// This function was causing deopts in Chrome.\r\n\tfunction dataToString(data) {\r\n\t\t//data.toString() might throw or return null if data is the return value of Console.log in Firefox (behavior depends on version)\r\n\t\ttry {\r\n\t\t\tif (data == null || data.toString() == null) return \"\";\r\n\t\t} catch (e) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t\treturn data;\r\n\t}\r\n\t// This function was causing deopts in Chrome.\r\n\tfunction injectTextNode(parentElement, first, index, data) {\r\n\t\ttry {\r\n\t\t\tinsertNode(parentElement, first, index);\r\n\t\t\tfirst.nodeValue = data;\r\n\t\t} catch (e) {} //IE erroneously throws error when appending an empty text node after a null\r\n\t}\r\n\r\n\tfunction flatten(list) {\r\n\t\t//recursively flatten array\r\n\t\tfor (var i = 0; i < list.length; i++) {\r\n\t\t\tif (isArray(list[i])) {\r\n\t\t\t\tlist = list.concat.apply([], list);\r\n\t\t\t\t//check current index again and flatten until there are no more nested arrays at that index\r\n\t\t\t\ti--;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn list;\r\n\t}\r\n\r\n\tfunction insertNode(parentElement, node, index) {\r\n\t\tparentElement.insertBefore(node, parentElement.childNodes[index] || null);\r\n\t}\r\n\r\n\tvar DELETION = 1, INSERTION = 2, MOVE = 3;\r\n\r\n\tfunction handleKeysDiffer(data, existing, cached, parentElement) {\r\n\t\tforKeys(data, function (key, i) {\r\n\t\t\texisting[key = key.key] = existing[key] ? {\r\n\t\t\t\taction: MOVE,\r\n\t\t\t\tindex: i,\r\n\t\t\t\tfrom: existing[key].index,\r\n\t\t\t\telement: cached.nodes[existing[key].index] || $document.createElement(\"div\")\r\n\t\t\t} : {action: INSERTION, index: i};\r\n\t\t});\r\n\t\tvar actions = [];\r\n\t\tfor (var prop in existing) actions.push(existing[prop]);\r\n\t\tvar changes = actions.sort(sortChanges), newCached = new Array(cached.length);\r\n\t\tnewCached.nodes = cached.nodes.slice();\r\n\r\n\t\tforEach(changes, function (change) {\r\n\t\t\tvar index = change.index;\r\n\t\t\tif (change.action === DELETION) {\r\n\t\t\t\tclear(cached[index].nodes, cached[index]);\r\n\t\t\t\tnewCached.splice(index, 1);\r\n\t\t\t}\r\n\t\t\tif (change.action === INSERTION) {\r\n\t\t\t\tvar dummy = $document.createElement(\"div\");\r\n\t\t\t\tdummy.key = data[index].attrs.key;\r\n\t\t\t\tinsertNode(parentElement, dummy, index);\r\n\t\t\t\tnewCached.splice(index, 0, {\r\n\t\t\t\t\tattrs: {key: data[index].attrs.key},\r\n\t\t\t\t\tnodes: [dummy]\r\n\t\t\t\t});\r\n\t\t\t\tnewCached.nodes[index] = dummy;\r\n\t\t\t}\r\n\r\n\t\t\tif (change.action === MOVE) {\r\n\t\t\t\tvar changeElement = change.element;\r\n\t\t\t\tvar maybeChanged = parentElement.childNodes[index];\r\n\t\t\t\tif (maybeChanged !== changeElement && changeElement !== null) {\r\n\t\t\t\t\tparentElement.insertBefore(changeElement, maybeChanged || null);\r\n\t\t\t\t}\r\n\t\t\t\tnewCached[index] = cached[change.from];\r\n\t\t\t\tnewCached.nodes[index] = changeElement;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn newCached;\r\n\t}\r\n\r\n\tfunction diffKeys(data, cached, existing, parentElement) {\r\n\t\tvar keysDiffer = data.length !== cached.length;\r\n\t\tif (!keysDiffer) {\r\n\t\t\tforKeys(data, function (attrs, i) {\r\n\t\t\t\tvar cachedCell = cached[i];\r\n\t\t\t\treturn keysDiffer = cachedCell && cachedCell.attrs && cachedCell.attrs.key !== attrs.key;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn keysDiffer ? handleKeysDiffer(data, existing, cached, parentElement) : cached;\r\n\t}\r\n\r\n\tfunction diffArray(data, cached, nodes) {\r\n\t\t//diff the array itself\r\n\r\n\t\t//update the list of DOM nodes by collecting the nodes from each item\r\n\t\tforEach(data, function (_, i) {\r\n\t\t\tif (cached[i] != null) nodes.push.apply(nodes, cached[i].nodes);\r\n\t\t})\r\n\t\t//remove items from the end of the array if the new array is shorter than the old one. if errors ever happen here, the issue is most likely\r\n\t\t//a bug in the construction of the `cached` data structure somewhere earlier in the program\r\n\t\tforEach(cached.nodes, function (node, i) {\r\n\t\t\tif (node.parentNode != null && nodes.indexOf(node) < 0) clear([node], [cached[i]]);\r\n\t\t})\r\n\t\tif (data.length < cached.length) cached.length = data.length;\r\n\t\tcached.nodes = nodes;\r\n\t}\r\n\r\n\tfunction buildArrayKeys(data) {\r\n\t\tvar guid = 0;\r\n\t\tforKeys(data, function () {\r\n\t\t\tforEach(data, function (attrs) {\r\n\t\t\t\tif ((attrs = attrs && attrs.attrs) && attrs.key == null) attrs.key = \"__mithril__\" + guid++;\r\n\t\t\t})\r\n\t\t\treturn 1;\r\n\t\t});\r\n\t}\r\n\r\n\tfunction maybeRecreateObject(data, cached, dataAttrKeys) {\r\n\t\t//if an element is different enough from the one in cache, recreate it\r\n\t\tif (data.tag !== cached.tag ||\r\n\t\t\t\tdataAttrKeys.sort().join() !== Object.keys(cached.attrs).sort().join() ||\r\n\t\t\t\tdata.attrs.id !== cached.attrs.id ||\r\n\t\t\t\tdata.attrs.key !== cached.attrs.key ||\r\n\t\t\t\t(m.redraw.strategy() === \"all\" && (!cached.configContext || cached.configContext.retain !== true)) ||\r\n\t\t\t\t(m.redraw.strategy() === \"diff\" && cached.configContext && cached.configContext.retain === false)) {\r\n\t\t\tif (cached.nodes.length) clear(cached.nodes);\r\n\t\t\tif (cached.configContext && isFunction(cached.configContext.onunload)) cached.configContext.onunload();\r\n\t\t\tif (cached.controllers) {\r\n\t\t\t\tforEach(cached.controllers, function (controller) {\r\n\t\t\t\t\tif (controller.unload) controller.onunload({preventDefault: noop});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getObjectNamespace(data, namespace) {\r\n\t\treturn data.attrs.xmlns ? data.attrs.xmlns :\r\n\t\t\tdata.tag === \"svg\" ? \"http://www.w3.org/2000/svg\" :\r\n\t\t\tdata.tag === \"math\" ? \"http://www.w3.org/1998/Math/MathML\" :\r\n\t\t\tnamespace;\r\n\t}\r\n\r\n\tfunction unloadCachedControllers(cached, views, controllers) {\r\n\t\tif (controllers.length) {\r\n\t\t\tcached.views = views;\r\n\t\t\tcached.controllers = controllers;\r\n\t\t\tforEach(controllers, function (controller) {\r\n\t\t\t\tif (controller.onunload && controller.onunload.$old) controller.onunload = controller.onunload.$old;\r\n\t\t\t\tif (pendingRequests && controller.onunload) {\r\n\t\t\t\t\tvar onunload = controller.onunload;\r\n\t\t\t\t\tcontroller.onunload = noop;\r\n\t\t\t\t\tcontroller.onunload.$old = onunload;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction scheduleConfigsToBeCalled(configs, data, node, isNew, cached) {\r\n\t\t//schedule configs to be called. They are called after `build`\r\n\t\t//finishes running\r\n\t\tif (isFunction(data.attrs.config)) {\r\n\t\t\tvar context = cached.configContext = cached.configContext || {};\r\n\r\n\t\t\t//bind\r\n\t\t\tconfigs.push(function() {\r\n\t\t\t\treturn data.attrs.config.call(data, node, !isNew, context, cached);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildUpdatedNode(cached, data, editable, hasKeys, namespace, views, configs, controllers) {\r\n\t\tvar node = cached.nodes[0];\r\n\t\tif (hasKeys) setAttributes(node, data.tag, data.attrs, cached.attrs, namespace);\r\n\t\tcached.children = build(node, data.tag, undefined, undefined, data.children, cached.children, false, 0, data.attrs.contenteditable ? node : editable, namespace, configs);\r\n\t\tcached.nodes.intact = true;\r\n\r\n\t\tif (controllers.length) {\r\n\t\t\tcached.views = views;\r\n\t\t\tcached.controllers = controllers;\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\t}\r\n\r\n\tfunction handleNonexistentNodes(data, parentElement, index) {\r\n\t\tvar nodes;\r\n\t\tif (data.$trusted) {\r\n\t\t\tnodes = injectHTML(parentElement, index, data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnodes = [$document.createTextNode(data)];\r\n\t\t\tif (!parentElement.nodeName.match(voidElements)) insertNode(parentElement, nodes[0], index);\r\n\t\t}\r\n\r\n\t\tvar cached = typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\" ? new data.constructor(data) : data;\r\n\t\tcached.nodes = nodes;\r\n\t\treturn cached;\r\n\t}\r\n\r\n\tfunction reattachNodes(data, cached, parentElement, editable, index, parentTag) {\r\n\t\tvar nodes = cached.nodes;\r\n\t\tif (!editable || editable !== $document.activeElement) {\r\n\t\t\tif (data.$trusted) {\r\n\t\t\t\tclear(nodes, cached)\r\n\t\t\t\tnodes = injectHTML(parentElement, index, data)\r\n\t\t\t} else if (parentTag === \"textarea\") {\r\n\t\t\t\t// <textarea> uses `value` instead of `nodeValue`.\r\n\t\t\t\tparentElement.value = data\r\n\t\t\t} else if (editable) {\r\n\t\t\t\t// contenteditable nodes use `innerHTML` instead of `nodeValue`.\r\n\t\t\t\teditable.innerHTML = data\r\n\t\t\t} else {\r\n\t\t\t\t// was a trusted string\r\n\t\t\t\tif (nodes[0].nodeType === 1 || nodes.length > 1 || (nodes[0].nodeValue.trim && !nodes[0].nodeValue.trim())) {\r\n\t\t\t\t\tclear(cached.nodes, cached)\r\n\t\t\t\t\tnodes = [$document.createTextNode(data)]\r\n\t\t\t\t}\r\n\t\t\t\tinjectTextNode(parentElement, nodes[0], index, data);\r\n\t\t\t}\r\n\t\t}\r\n\t\tcached = new data.constructor(data);\r\n\t\tcached.nodes = nodes;\r\n\t\treturn cached;\r\n\t}\r\n\r\n\tfunction handleText(cached, data, index, parentElement, shouldReattach, editable, parentTag) {\r\n\t\t//handle text nodes\r\n\t\treturn cached.nodes.length === 0 ? handleNonexistentNodes(data, parentElement, index) :\r\n\t\t\tcached.valueOf() !== data.valueOf() || shouldReattach === true ?\r\n\t\t\t\treattachNodes(data, cached, parentElement, editable, index, parentTag) :\r\n\t\t\t(cached.nodes.intact = true, cached);\r\n\t}\r\n\r\n\tfunction getSubArrayCount(item) {\r\n\t\tif (item.$trusted) {\r\n\t\t\t//fix offset of next element if item was a trusted string w/ more than one html element\r\n\t\t\t//the first clause in the regexp matches elements\r\n\t\t\t//the second clause (after the pipe) matches text nodes\r\n\t\t\tvar match = item.match(/<[^\\/]|\\>\\s*[^<]/g);\r\n\t\t\tif (match != null) return match.length;\r\n\t\t}\r\n\t\telse if (isArray(item)) {\r\n\t\t\treturn item.length;\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tfunction buildArray(data, cached, parentElement, index, parentTag, shouldReattach, editable, namespace, configs) {\r\n\t\tdata = flatten(data);\r\n\t\tvar nodes = [], intact = cached.length === data.length, subArrayCount = 0;\r\n\r\n\t\t//keys algorithm: sort elements without recreating them if keys are present\r\n\t\t//1) create a map of all existing keys, and mark all for deletion\r\n\t\t//2) add new keys to map and mark them for addition\r\n\t\t//3) if key exists in new list, change action from deletion to a move\r\n\t\t//4) for each key, handle its corresponding action as marked in previous steps\r\n\t\tvar existing = {}, shouldMaintainIdentities = false;\r\n\t\tforKeys(cached, function (attrs, i) {\r\n\t\t\tshouldMaintainIdentities = true;\r\n\t\t\texisting[cached[i].attrs.key] = {action: DELETION, index: i};\r\n\t\t});\r\n\r\n\t\tbuildArrayKeys(data);\r\n\t\tif (shouldMaintainIdentities) cached = diffKeys(data, cached, existing, parentElement);\r\n\t\t//end key algorithm\r\n\r\n\t\tvar cacheCount = 0;\r\n\t\t//faster explicitly written\r\n\t\tfor (var i = 0, len = data.length; i < len; i++) {\r\n\t\t\t//diff each item in the array\r\n\t\t\tvar item = build(parentElement, parentTag, cached, index, data[i], cached[cacheCount], shouldReattach, index + subArrayCount || subArrayCount, editable, namespace, configs);\r\n\r\n\t\t\tif (item !== undefined) {\r\n\t\t\t\tintact = intact && item.nodes.intact;\r\n\t\t\t\tsubArrayCount += getSubArrayCount(item);\r\n\t\t\t\tcached[cacheCount++] = item;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!intact) diffArray(data, cached, nodes);\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction makeCache(data, cached, index, parentIndex, parentCache) {\r\n\t\tif (cached != null) {\r\n\t\t\tif (type.call(cached) === type.call(data)) return cached;\r\n\r\n\t\t\tif (parentCache && parentCache.nodes) {\r\n\t\t\t\tvar offset = index - parentIndex, end = offset + (isArray(data) ? data : cached.nodes).length;\r\n\t\t\t\tclear(parentCache.nodes.slice(offset, end), parentCache.slice(offset, end));\r\n\t\t\t} else if (cached.nodes) {\r\n\t\t\t\tclear(cached.nodes, cached);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcached = new data.constructor();\r\n\t\t//if constructor creates a virtual dom element, use a blank object\r\n\t\t//as the base cached node instead of copying the virtual el (#277)\r\n\t\tif (cached.tag) cached = {};\r\n\t\tcached.nodes = [];\r\n\t\treturn cached;\r\n\t}\r\n\r\n\tfunction constructNode(data, namespace) {\r\n\t\treturn namespace === undefined ?\r\n\t\t\tdata.attrs.is ? $document.createElement(data.tag, data.attrs.is) : $document.createElement(data.tag) :\r\n\t\t\tdata.attrs.is ? $document.createElementNS(namespace, data.tag, data.attrs.is) : $document.createElementNS(namespace, data.tag);\r\n\t}\r\n\r\n\tfunction constructAttrs(data, node, namespace, hasKeys) {\r\n\t\treturn hasKeys ? setAttributes(node, data.tag, data.attrs, {}, namespace) : data.attrs;\r\n\t}\r\n\r\n\tfunction constructChildren(data, node, cached, editable, namespace, configs) {\r\n\t\treturn data.children != null && data.children.length > 0 ?\r\n\t\t\tbuild(node, data.tag, undefined, undefined, data.children, cached.children, true, 0, data.attrs.contenteditable ? node : editable, namespace, configs) :\r\n\t\t\tdata.children;\r\n\t}\r\n\r\n\tfunction reconstructCached(data, attrs, children, node, namespace, views, controllers) {\r\n\t\tvar cached = {tag: data.tag, attrs: attrs, children: children, nodes: [node]};\r\n\t\tunloadCachedControllers(cached, views, controllers);\r\n\t\tif (cached.children && !cached.children.nodes) cached.children.nodes = [];\r\n\t\t//edge case: setting value on <select> doesn't work before children exist, so set it again after children have been created\r\n\t\tif (data.tag === \"select\" && \"value\" in data.attrs) setAttributes(node, data.tag, {value: data.attrs.value}, {}, namespace);\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction getController(views, view, cachedControllers, controller) {\r\n\t\tvar controllerIndex = m.redraw.strategy() === \"diff\" && views ? views.indexOf(view) : -1;\r\n\t\treturn controllerIndex > -1 ? cachedControllers[controllerIndex] :\r\n\t\t\ttypeof controller === \"function\" ? new controller() : {};\r\n\t}\r\n\r\n\tfunction updateLists(views, controllers, view, controller) {\r\n\t\tif (controller.onunload != null) unloaders.push({controller: controller, handler: controller.onunload});\r\n\t\tviews.push(view);\r\n\t\tcontrollers.push(controller);\r\n\t}\r\n\r\n\tfunction checkView(data, view, cached, cachedControllers, controllers, views) {\r\n\t\tvar controller = getController(cached.views, view, cachedControllers, data.controller);\r\n\t\t//Faster to coerce to number and check for NaN\r\n\t\tvar key = +(data && data.attrs && data.attrs.key);\r\n\t\tdata = pendingRequests === 0 || forcing || cachedControllers && cachedControllers.indexOf(controller) > -1 ? data.view(controller) : {tag: \"placeholder\"};\r\n\t\tif (data.subtree === \"retain\") return cached;\r\n\t\tif (key === key) (data.attrs = data.attrs || {}).key = key;\r\n\t\tupdateLists(views, controllers, view, controller);\r\n\t\treturn data;\r\n\t}\r\n\r\n\tfunction markViews(data, cached, views, controllers) {\r\n\t\tvar cachedControllers = cached && cached.controllers;\r\n\t\twhile (data.view != null) data = checkView(data, data.view.$original || data.view, cached, cachedControllers, controllers, views);\r\n\t\treturn data;\r\n\t}\r\n\r\n\tfunction buildObject(data, cached, editable, parentElement, index, shouldReattach, namespace, configs) {\r\n\t\tvar views = [], controllers = [];\r\n\t\tdata = markViews(data, cached, views, controllers);\r\n\t\tif (!data.tag && controllers.length) throw new Error(\"Component template must return a virtual element, not an array, string, etc.\");\r\n\t\tdata.attrs = data.attrs || {};\r\n\t\tcached.attrs = cached.attrs || {};\r\n\t\tvar dataAttrKeys = Object.keys(data.attrs);\r\n\t\tvar hasKeys = dataAttrKeys.length > (\"key\" in data.attrs ? 1 : 0);\r\n\t\tmaybeRecreateObject(data, cached, dataAttrKeys);\r\n\t\tif (!isString(data.tag)) return;\r\n\t\tvar isNew = cached.nodes.length === 0;\r\n\t\tnamespace = getObjectNamespace(data, namespace);\r\n\t\tvar node;\r\n\t\tif (isNew) {\r\n\t\t\tnode = constructNode(data, namespace);\r\n\t\t\t//set attributes first, then create children\r\n\t\t\tvar attrs = constructAttrs(data, node, namespace, hasKeys)\r\n\t\t\tvar children = constructChildren(data, node, cached, editable, namespace, configs);\r\n\t\t\tcached = reconstructCached(data, attrs, children, node, namespace, views, controllers);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnode = buildUpdatedNode(cached, data, editable, hasKeys, namespace, views, configs, controllers);\r\n\t\t}\r\n\t\tif (isNew || shouldReattach === true && node != null) insertNode(parentElement, node, index);\r\n\t\t//schedule configs to be called. They are called after `build`\r\n\t\t//finishes running\r\n\t\tscheduleConfigsToBeCalled(configs, data, node, isNew, cached);\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction build(parentElement, parentTag, parentCache, parentIndex, data, cached, shouldReattach, index, editable, namespace, configs) {\r\n\t\t//`build` is a recursive function that manages creation/diffing/removal\r\n\t\t//of DOM elements based on comparison between `data` and `cached`\r\n\t\t//the diff algorithm can be summarized as this:\r\n\t\t//1 - compare `data` and `cached`\r\n\t\t//2 - if they are different, copy `data` to `cached` and update the DOM\r\n\t\t//    based on what the difference is\r\n\t\t//3 - recursively apply this algorithm for every array and for the\r\n\t\t//    children of every virtual element\r\n\r\n\t\t//the `cached` data structure is essentially the same as the previous\r\n\t\t//redraw's `data` data structure, with a few additions:\r\n\t\t//- `cached` always has a property called `nodes`, which is a list of\r\n\t\t//   DOM elements that correspond to the data represented by the\r\n\t\t//   respective virtual element\r\n\t\t//- in order to support attaching `nodes` as a property of `cached`,\r\n\t\t//   `cached` is *always* a non-primitive object, i.e. if the data was\r\n\t\t//   a string, then cached is a String instance. If data was `null` or\r\n\t\t//   `undefined`, cached is `new String(\"\")`\r\n\t\t//- `cached also has a `configContext` property, which is the state\r\n\t\t//   storage object exposed by config(element, isInitialized, context)\r\n\t\t//- when `cached` is an Object, it represents a virtual element; when\r\n\t\t//   it's an Array, it represents a list of elements; when it's a\r\n\t\t//   String, Number or Boolean, it represents a text node\r\n\r\n\t\t//`parentElement` is a DOM element used for W3C DOM API calls\r\n\t\t//`parentTag` is only used for handling a corner case for textarea\r\n\t\t//values\r\n\t\t//`parentCache` is used to remove nodes in some multi-node cases\r\n\t\t//`parentIndex` and `index` are used to figure out the offset of nodes.\r\n\t\t//They're artifacts from before arrays started being flattened and are\r\n\t\t//likely refactorable\r\n\t\t//`data` and `cached` are, respectively, the new and old nodes being\r\n\t\t//diffed\r\n\t\t//`shouldReattach` is a flag indicating whether a parent node was\r\n\t\t//recreated (if so, and if this node is reused, then this node must\r\n\t\t//reattach itself to the new parent)\r\n\t\t//`editable` is a flag that indicates whether an ancestor is\r\n\t\t//contenteditable\r\n\t\t//`namespace` indicates the closest HTML namespace as it cascades down\r\n\t\t//from an ancestor\r\n\t\t//`configs` is a list of config functions to run after the topmost\r\n\t\t//`build` call finishes running\r\n\r\n\t\t//there's logic that relies on the assumption that null and undefined\r\n\t\t//data are equivalent to empty strings\r\n\t\t//- this prevents lifecycle surprises from procedural helpers that mix\r\n\t\t//  implicit and explicit return statements (e.g.\r\n\t\t//  function foo() {if (cond) return m(\"div\")}\r\n\t\t//- it simplifies diffing code\r\n\t\tdata = dataToString(data);\r\n\t\tif (data.subtree === \"retain\") return cached;\r\n\t\tcached = makeCache(data, cached, index, parentIndex, parentCache);\r\n\t\treturn isArray(data) ? buildArray(data, cached, parentElement, index, parentTag, shouldReattach, editable, namespace, configs) :\r\n\t\t\tdata != null && isObject(data) ? buildObject(data, cached, editable, parentElement, index, shouldReattach, namespace, configs) :\r\n\t\t\t!isFunction(data) ? handleText(cached, data, index, parentElement, shouldReattach, editable, parentTag) :\r\n\t\t\tcached;\r\n\t}\r\n\tfunction sortChanges(a, b) { return a.action - b.action || a.index - b.index; }\r\n\tfunction setAttributes(node, tag, dataAttrs, cachedAttrs, namespace) {\r\n\t\tfor (var attrName in dataAttrs) {\r\n\t\t\tvar dataAttr = dataAttrs[attrName];\r\n\t\t\tvar cachedAttr = cachedAttrs[attrName];\r\n\t\t\tif (!(attrName in cachedAttrs) || (cachedAttr !== dataAttr)) {\r\n\t\t\t\tcachedAttrs[attrName] = dataAttr;\r\n\t\t\t\ttry {\r\n\t\t\t\t\t//`config` isn't a real attributes, so ignore it\r\n\t\t\t\t\tif (attrName === \"config\" || attrName === \"key\") continue;\r\n\t\t\t\t\t//hook event handlers to the auto-redrawing system\r\n\t\t\t\t\telse if (isFunction(dataAttr) && attrName.slice(0, 2) === \"on\") {\r\n\t\t\t\t\t\tnode[attrName] = autoredraw(dataAttr, node);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//handle `style: {...}`\r\n\t\t\t\t\telse if (attrName === \"style\" && dataAttr != null && isObject(dataAttr)) {\r\n\t\t\t\t\t\tfor (var rule in dataAttr) {\r\n\t\t\t\t\t\t\tif (cachedAttr == null || cachedAttr[rule] !== dataAttr[rule]) node.style[rule] = dataAttr[rule];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (var rule in cachedAttr) {\r\n\t\t\t\t\t\t\tif (!(rule in dataAttr)) node.style[rule] = \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//handle SVG\r\n\t\t\t\t\telse if (namespace != null) {\r\n\t\t\t\t\t\tif (attrName === \"href\") node.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", dataAttr);\r\n\t\t\t\t\t\telse node.setAttribute(attrName === \"className\" ? \"class\" : attrName, dataAttr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//handle cases that are properties (but ignore cases where we should use setAttribute instead)\r\n\t\t\t\t\t//- list and form are typically used as strings, but are DOM element references in js\r\n\t\t\t\t\t//- when using CSS selectors (e.g. `m(\"[style='']\")`), style is used as a string, but it's an object in js\r\n\t\t\t\t\telse if (attrName in node && attrName !== \"list\" && attrName !== \"style\" && attrName !== \"form\" && attrName !== \"type\" && attrName !== \"width\" && attrName !== \"height\") {\r\n\t\t\t\t\t\t//#348 don't set the value if not needed otherwise cursor placement breaks in Chrome\r\n\t\t\t\t\t\tif (tag !== \"input\" || node[attrName] !== dataAttr) node[attrName] = dataAttr;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse node.setAttribute(attrName, dataAttr);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\t//swallow IE's invalid argument errors to mimic HTML's fallback-to-doing-nothing-on-invalid-attributes behavior\r\n\t\t\t\t\tif (e.message.indexOf(\"Invalid argument\") < 0) throw e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//#348 dataAttr may not be a string, so use loose comparison (double equal) instead of strict (triple equal)\r\n\t\t\telse if (attrName === \"value\" && tag === \"input\" && node.value != dataAttr) {\r\n\t\t\t\tnode.value = dataAttr;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cachedAttrs;\r\n\t}\r\n\tfunction clear(nodes, cached) {\r\n\t\tfor (var i = nodes.length - 1; i > -1; i--) {\r\n\t\t\tif (nodes[i] && nodes[i].parentNode) {\r\n\t\t\t\ttry { nodes[i].parentNode.removeChild(nodes[i]); }\r\n\t\t\t\tcatch (e) {} //ignore if this fails due to order of events (see http://stackoverflow.com/questions/21926083/failed-to-execute-removechild-on-node)\r\n\t\t\t\tcached = [].concat(cached);\r\n\t\t\t\tif (cached[i]) unload(cached[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//release memory if nodes is an array. This check should fail if nodes is a NodeList (see loop above)\r\n\t\tif (nodes.length) nodes.length = 0;\r\n\t}\r\n\tfunction unload(cached) {\r\n\t\tif (cached.configContext && isFunction(cached.configContext.onunload)) {\r\n\t\t\tcached.configContext.onunload();\r\n\t\t\tcached.configContext.onunload = null;\r\n\t\t}\r\n\t\tif (cached.controllers) {\r\n\t\t\tforEach(cached.controllers, function (controller) {\r\n\t\t\t\tif (isFunction(controller.onunload)) controller.onunload({preventDefault: noop});\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (cached.children) {\r\n\t\t\tif (isArray(cached.children)) forEach(cached.children, unload);\r\n\t\t\telse if (cached.children.tag) unload(cached.children);\r\n\t\t}\r\n\t}\r\n\tfunction injectHTML(parentElement, index, data) {\r\n\t\tvar nextSibling = parentElement.childNodes[index];\r\n\t\tif (nextSibling) {\r\n\t\t\tvar isElement = nextSibling.nodeType !== 1;\r\n\t\t\tvar placeholder = $document.createElement(\"span\");\r\n\t\t\tif (isElement) {\r\n\t\t\t\tparentElement.insertBefore(placeholder, nextSibling || null);\r\n\t\t\t\tplaceholder.insertAdjacentHTML(\"beforebegin\", data);\r\n\t\t\t\tparentElement.removeChild(placeholder);\r\n\t\t\t}\r\n\t\t\telse nextSibling.insertAdjacentHTML(\"beforebegin\", data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (window.Range && window.Range.prototype.createContextualFragment) {\r\n\t\t\t\tparentElement.appendChild($document.createRange().createContextualFragment(data));\r\n\t\t\t}\r\n\t\t\telse parentElement.insertAdjacentHTML(\"beforeend\", data);\r\n\t\t}\r\n\t\tvar nodes = [];\r\n\t\twhile (parentElement.childNodes[index] !== nextSibling) {\r\n\t\t\tnodes.push(parentElement.childNodes[index]);\r\n\t\t\tindex++;\r\n\t\t}\r\n\t\treturn nodes;\r\n\t}\r\n\tfunction autoredraw(callback, object) {\r\n\t\treturn function(e) {\r\n\t\t\te = e || event;\r\n\t\t\tm.redraw.strategy(\"diff\");\r\n\t\t\tm.startComputation();\r\n\t\t\ttry { return callback.call(object, e); }\r\n\t\t\tfinally {\r\n\t\t\t\tendFirstComputation();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tvar html;\r\n\tvar documentNode = {\r\n\t\tappendChild: function(node) {\r\n\t\t\tif (html === undefined) html = $document.createElement(\"html\");\r\n\t\t\tif ($document.documentElement && $document.documentElement !== node) {\r\n\t\t\t\t$document.replaceChild(node, $document.documentElement);\r\n\t\t\t}\r\n\t\t\telse $document.appendChild(node);\r\n\t\t\tthis.childNodes = $document.childNodes;\r\n\t\t},\r\n\t\tinsertBefore: function(node) {\r\n\t\t\tthis.appendChild(node);\r\n\t\t},\r\n\t\tchildNodes: []\r\n\t};\r\n\tvar nodeCache = [], cellCache = {};\r\n\tm.render = function(root, cell, forceRecreation) {\r\n\t\tvar configs = [];\r\n\t\tif (!root) throw new Error(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\");\r\n\t\tvar id = getCellCacheKey(root);\r\n\t\tvar isDocumentRoot = root === $document;\r\n\t\tvar node = isDocumentRoot || root === $document.documentElement ? documentNode : root;\r\n\t\tif (isDocumentRoot && cell.tag !== \"html\") cell = {tag: \"html\", attrs: {}, children: cell};\r\n\t\tif (cellCache[id] === undefined) clear(node.childNodes);\r\n\t\tif (forceRecreation === true) reset(root);\r\n\t\tcellCache[id] = build(node, null, undefined, undefined, cell, cellCache[id], false, 0, null, undefined, configs);\r\n\t\tforEach(configs, function (config) { config(); });\r\n\t};\r\n\tfunction getCellCacheKey(element) {\r\n\t\tvar index = nodeCache.indexOf(element);\r\n\t\treturn index < 0 ? nodeCache.push(element) - 1 : index;\r\n\t}\r\n\r\n\tm.trust = function(value) {\r\n\t\tvalue = new String(value);\r\n\t\tvalue.$trusted = true;\r\n\t\treturn value;\r\n\t};\r\n\r\n\tfunction gettersetter(store) {\r\n\t\tvar prop = function() {\r\n\t\t\tif (arguments.length) store = arguments[0];\r\n\t\t\treturn store;\r\n\t\t};\r\n\r\n\t\tprop.toJSON = function() {\r\n\t\t\treturn store;\r\n\t\t};\r\n\r\n\t\treturn prop;\r\n\t}\r\n\r\n\tm.prop = function (store) {\r\n\t\t//note: using non-strict equality check here because we're checking if store is null OR undefined\r\n\t\tif ((store != null && isObject(store) || isFunction(store)) && isFunction(store.then)) {\r\n\t\t\treturn propify(store);\r\n\t\t}\r\n\r\n\t\treturn gettersetter(store);\r\n\t};\r\n\r\n\tvar roots = [], components = [], controllers = [], lastRedrawId = null, lastRedrawCallTime = 0, computePreRedrawHook = null, computePostRedrawHook = null, topComponent, unloaders = [];\r\n\tvar FRAME_BUDGET = 16; //60 frames per second = 1 call per 16 ms\r\n\tfunction parameterize(component, args) {\r\n\t\tvar controller = function() {\r\n\t\t\treturn (component.controller || noop).apply(this, args) || this;\r\n\t\t};\r\n\t\tif (component.controller) controller.prototype = component.controller.prototype;\r\n\t\tvar view = function(ctrl) {\r\n\t\t\tvar currentArgs = arguments.length > 1 ? args.concat([].slice.call(arguments, 1)) : args;\r\n\t\t\treturn component.view.apply(component, currentArgs ? [ctrl].concat(currentArgs) : [ctrl]);\r\n\t\t};\r\n\t\tview.$original = component.view;\r\n\t\tvar output = {controller: controller, view: view};\r\n\t\tif (args[0] && args[0].key != null) output.attrs = {key: args[0].key};\r\n\t\treturn output;\r\n\t}\r\n\tm.component = function(component) {\r\n\t\tfor (var args = [], i = 1; i < arguments.length; i++) args.push(arguments[i]);\r\n\t\treturn parameterize(component, args);\r\n\t};\r\n\tm.mount = m.module = function(root, component) {\r\n\t\tif (!root) throw new Error(\"Please ensure the DOM element exists before rendering a template into it.\");\r\n\t\tvar index = roots.indexOf(root);\r\n\t\tif (index < 0) index = roots.length;\r\n\r\n\t\tvar isPrevented = false;\r\n\t\tvar event = {preventDefault: function() {\r\n\t\t\tisPrevented = true;\r\n\t\t\tcomputePreRedrawHook = computePostRedrawHook = null;\r\n\t\t}};\r\n\r\n\t\tforEach(unloaders, function (unloader) {\r\n\t\t\tunloader.handler.call(unloader.controller, event);\r\n\t\t\tunloader.controller.onunload = null;\r\n\t\t});\r\n\r\n\t\tif (isPrevented) {\r\n\t\t\tforEach(unloaders, function (unloader) {\r\n\t\t\t\tunloader.controller.onunload = unloader.handler;\r\n\t\t\t});\r\n\t\t}\r\n\t\telse unloaders = [];\r\n\r\n\t\tif (controllers[index] && isFunction(controllers[index].onunload)) {\r\n\t\t\tcontrollers[index].onunload(event);\r\n\t\t}\r\n\r\n\t\tvar isNullComponent = component === null;\r\n\r\n\t\tif (!isPrevented) {\r\n\t\t\tm.redraw.strategy(\"all\");\r\n\t\t\tm.startComputation();\r\n\t\t\troots[index] = root;\r\n\t\t\tvar currentComponent = component ? (topComponent = component) : (topComponent = component = {controller: noop});\r\n\t\t\tvar controller = new (component.controller || noop)();\r\n\t\t\t//controllers may call m.mount recursively (via m.route redirects, for example)\r\n\t\t\t//this conditional ensures only the last recursive m.mount call is applied\r\n\t\t\tif (currentComponent === topComponent) {\r\n\t\t\t\tcontrollers[index] = controller;\r\n\t\t\t\tcomponents[index] = component;\r\n\t\t\t}\r\n\t\t\tendFirstComputation();\r\n\t\t\tif (isNullComponent) {\r\n\t\t\t\tremoveRootElement(root, index);\r\n\t\t\t}\r\n\t\t\treturn controllers[index];\r\n\t\t}\r\n\t\tif (isNullComponent) {\r\n\t\t\tremoveRootElement(root, index);\r\n\t\t}\r\n\t};\r\n\r\n\tfunction removeRootElement(root, index) {\r\n\t\troots.splice(index, 1);\r\n\t\tcontrollers.splice(index, 1);\r\n\t\tcomponents.splice(index, 1);\r\n\t\treset(root);\r\n\t\tnodeCache.splice(getCellCacheKey(root), 1);\r\n\t}\r\n\r\n\tvar redrawing = false, forcing = false;\r\n\tm.redraw = function(force) {\r\n\t\tif (redrawing) return;\r\n\t\tredrawing = true;\r\n\t\tif (force) forcing = true;\r\n\t\ttry {\r\n\t\t\t//lastRedrawId is a positive number if a second redraw is requested before the next animation frame\r\n\t\t\t//lastRedrawID is null if it's the first redraw and not an event handler\r\n\t\t\tif (lastRedrawId && !force) {\r\n\t\t\t\t//when setTimeout: only reschedule redraw if time between now and previous redraw is bigger than a frame, otherwise keep currently scheduled timeout\r\n\t\t\t\t//when rAF: always reschedule redraw\r\n\t\t\t\tif ($requestAnimationFrame === window.requestAnimationFrame || new Date - lastRedrawCallTime > FRAME_BUDGET) {\r\n\t\t\t\t\tif (lastRedrawId > 0) $cancelAnimationFrame(lastRedrawId);\r\n\t\t\t\t\tlastRedrawId = $requestAnimationFrame(redraw, FRAME_BUDGET);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tredraw();\r\n\t\t\t\tlastRedrawId = $requestAnimationFrame(function() { lastRedrawId = null; }, FRAME_BUDGET);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tredrawing = forcing = false;\r\n\t\t}\r\n\t};\r\n\tm.redraw.strategy = m.prop();\r\n\tfunction redraw() {\r\n\t\tif (computePreRedrawHook) {\r\n\t\t\tcomputePreRedrawHook();\r\n\t\t\tcomputePreRedrawHook = null;\r\n\t\t}\r\n\t\tforEach(roots, function (root, i) {\r\n\t\t\tvar component = components[i];\r\n\t\t\tif (controllers[i]) {\r\n\t\t\t\tvar args = [controllers[i]];\r\n\t\t\t\tm.render(root, component.view ? component.view(controllers[i], args) : \"\");\r\n\t\t\t}\r\n\t\t});\r\n\t\t//after rendering within a routed context, we need to scroll back to the top, and fetch the document title for history.pushState\r\n\t\tif (computePostRedrawHook) {\r\n\t\t\tcomputePostRedrawHook();\r\n\t\t\tcomputePostRedrawHook = null;\r\n\t\t}\r\n\t\tlastRedrawId = null;\r\n\t\tlastRedrawCallTime = new Date;\r\n\t\tm.redraw.strategy(\"diff\");\r\n\t}\r\n\r\n\tvar pendingRequests = 0;\r\n\tm.startComputation = function() { pendingRequests++; };\r\n\tm.endComputation = function() {\r\n\t\tif (pendingRequests > 1) pendingRequests--;\r\n\t\telse {\r\n\t\t\tpendingRequests = 0;\r\n\t\t\tm.redraw();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction endFirstComputation() {\r\n\t\tif (m.redraw.strategy() === \"none\") {\r\n\t\t\tpendingRequests--;\r\n\t\t\tm.redraw.strategy(\"diff\");\r\n\t\t}\r\n\t\telse m.endComputation();\r\n\t}\r\n\r\n\tm.withAttr = function(prop, withAttrCallback, callbackThis) {\r\n\t\treturn function(e) {\r\n\t\t\te = e || event;\r\n\t\t\tvar currentTarget = e.currentTarget || this;\r\n\t\t\tvar _this = callbackThis || this;\r\n\t\t\twithAttrCallback.call(_this, prop in currentTarget ? currentTarget[prop] : currentTarget.getAttribute(prop));\r\n\t\t};\r\n\t};\r\n\r\n\t//routing\r\n\tvar modes = {pathname: \"\", hash: \"#\", search: \"?\"};\r\n\tvar redirect = noop, routeParams, currentRoute, isDefaultRoute = false;\r\n\tm.route = function(root, arg1, arg2, vdom) {\r\n\t\t//m.route()\r\n\t\tif (arguments.length === 0) return currentRoute;\r\n\t\t//m.route(el, defaultRoute, routes)\r\n\t\telse if (arguments.length === 3 && isString(arg1)) {\r\n\t\t\tredirect = function(source) {\r\n\t\t\t\tvar path = currentRoute = normalizeRoute(source);\r\n\t\t\t\tif (!routeByValue(root, arg2, path)) {\r\n\t\t\t\t\tif (isDefaultRoute) throw new Error(\"Ensure the default route matches one of the routes defined in m.route\");\r\n\t\t\t\t\tisDefaultRoute = true;\r\n\t\t\t\t\tm.route(arg1, true);\r\n\t\t\t\t\tisDefaultRoute = false;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tvar listener = m.route.mode === \"hash\" ? \"onhashchange\" : \"onpopstate\";\r\n\t\t\twindow[listener] = function() {\r\n\t\t\t\tvar path = $location[m.route.mode];\r\n\t\t\t\tif (m.route.mode === \"pathname\") path += $location.search;\r\n\t\t\t\tif (currentRoute !== normalizeRoute(path)) redirect(path);\r\n\t\t\t};\r\n\r\n\t\t\tcomputePreRedrawHook = setScroll;\r\n\t\t\twindow[listener]();\r\n\t\t}\r\n\t\t//config: m.route\r\n\t\telse if (root.addEventListener || root.attachEvent) {\r\n\t\t\troot.href = (m.route.mode !== 'pathname' ? $location.pathname : '') + modes[m.route.mode] + vdom.attrs.href;\r\n\t\t\tif (root.addEventListener) {\r\n\t\t\t\troot.removeEventListener(\"click\", routeUnobtrusive);\r\n\t\t\t\troot.addEventListener(\"click\", routeUnobtrusive);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\troot.detachEvent(\"onclick\", routeUnobtrusive);\r\n\t\t\t\troot.attachEvent(\"onclick\", routeUnobtrusive);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//m.route(route, params, shouldReplaceHistoryEntry)\r\n\t\telse if (isString(root)) {\r\n\t\t\tvar oldRoute = currentRoute;\r\n\t\t\tcurrentRoute = root;\r\n\t\t\tvar args = arg1 || {};\r\n\t\t\tvar queryIndex = currentRoute.indexOf(\"?\");\r\n\t\t\tvar params = queryIndex > -1 ? parseQueryString(currentRoute.slice(queryIndex + 1)) : {};\r\n\t\t\tfor (var i in args) params[i] = args[i];\r\n\t\t\tvar querystring = buildQueryString(params);\r\n\t\t\tvar currentPath = queryIndex > -1 ? currentRoute.slice(0, queryIndex) : currentRoute;\r\n\t\t\tif (querystring) currentRoute = currentPath + (currentPath.indexOf(\"?\") === -1 ? \"?\" : \"&\") + querystring;\r\n\r\n\t\t\tvar shouldReplaceHistoryEntry = (arguments.length === 3 ? arg2 : arg1) === true || oldRoute === root;\r\n\r\n\t\t\tif (window.history.pushState) {\r\n\t\t\t\tcomputePreRedrawHook = setScroll;\r\n\t\t\t\tcomputePostRedrawHook = function() {\r\n\t\t\t\t\twindow.history[shouldReplaceHistoryEntry ? \"replaceState\" : \"pushState\"](null, $document.title, modes[m.route.mode] + currentRoute);\r\n\t\t\t\t};\r\n\t\t\t\tredirect(modes[m.route.mode] + currentRoute);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$location[m.route.mode] = currentRoute;\r\n\t\t\t\tredirect(modes[m.route.mode] + currentRoute);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tm.route.param = function(key) {\r\n\t\tif (!routeParams) throw new Error(\"You must call m.route(element, defaultRoute, routes) before calling m.route.param()\");\r\n\t\tif( !key ){\r\n\t\t\treturn routeParams;\r\n\t\t}\r\n\t\treturn routeParams[key];\r\n\t};\r\n\tm.route.mode = \"search\";\r\n\tfunction normalizeRoute(route) {\r\n\t\treturn route.slice(modes[m.route.mode].length);\r\n\t}\r\n\tfunction routeByValue(root, router, path) {\r\n\t\trouteParams = {};\r\n\r\n\t\tvar queryStart = path.indexOf(\"?\");\r\n\t\tif (queryStart !== -1) {\r\n\t\t\trouteParams = parseQueryString(path.substr(queryStart + 1, path.length));\r\n\t\t\tpath = path.substr(0, queryStart);\r\n\t\t}\r\n\r\n\t\t// Get all routes and check if there's\r\n\t\t// an exact match for the current path\r\n\t\tvar keys = Object.keys(router);\r\n\t\tvar index = keys.indexOf(path);\r\n\t\tif(index !== -1){\r\n\t\t\tm.mount(root, router[keys [index]]);\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tfor (var route in router) {\r\n\t\t\tif (route === path) {\r\n\t\t\t\tm.mount(root, router[route]);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tvar matcher = new RegExp(\"^\" + route.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\").replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\");\r\n\r\n\t\t\tif (matcher.test(path)) {\r\n\t\t\t\tpath.replace(matcher, function() {\r\n\t\t\t\t\tvar keys = route.match(/:[^\\/]+/g) || [];\r\n\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2);\r\n\t\t\t\t\tforEach(keys, function (key, i) {\r\n\t\t\t\t\t\trouteParams[key.replace(/:|\\./g, \"\")] = decodeURIComponent(values[i]);\r\n\t\t\t\t\t})\r\n\t\t\t\t\tm.mount(root, router[route]);\r\n\t\t\t\t});\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction routeUnobtrusive(e) {\r\n\t\te = e || event;\r\n\r\n\t\tif (e.ctrlKey || e.metaKey || e.which === 2) return;\r\n\r\n\t\tif (e.preventDefault) e.preventDefault();\r\n\t\telse e.returnValue = false;\r\n\r\n\t\tvar currentTarget = e.currentTarget || e.srcElement;\r\n\t\tvar args = m.route.mode === \"pathname\" && currentTarget.search ? parseQueryString(currentTarget.search.slice(1)) : {};\r\n\t\twhile (currentTarget && currentTarget.nodeName.toUpperCase() !== \"A\") currentTarget = currentTarget.parentNode;\r\n\t\t// clear pendingRequests because we want an immediate route change\r\n\t\tpendingRequests = 0;\r\n\t\tm.route(currentTarget[m.route.mode].slice(modes[m.route.mode].length), args);\r\n\t}\r\n\tfunction setScroll() {\r\n\t\tif (m.route.mode !== \"hash\" && $location.hash) $location.hash = $location.hash;\r\n\t\telse window.scrollTo(0, 0);\r\n\t}\r\n\tfunction buildQueryString(object, prefix) {\r\n\t\tvar duplicates = {};\r\n\t\tvar str = [];\r\n\t\tfor (var prop in object) {\r\n\t\t\tvar key = prefix ? prefix + \"[\" + prop + \"]\" : prop;\r\n\t\t\tvar value = object[prop];\r\n\r\n\t\t\tif (value === null) {\r\n\t\t\t\tstr.push(encodeURIComponent(key));\r\n\t\t\t} else if (isObject(value)) {\r\n\t\t\t\tstr.push(buildQueryString(value, key));\r\n\t\t\t} else if (isArray(value)) {\r\n\t\t\t\tvar keys = [];\r\n\t\t\t\tduplicates[key] = duplicates[key] || {};\r\n\t\t\t\tforEach(value, function (item) {\r\n\t\t\t\t\tif (!duplicates[key][item]) {\r\n\t\t\t\t\t\tduplicates[key][item] = true;\r\n\t\t\t\t\t\tkeys.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(item));\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tstr.push(keys.join(\"&\"));\r\n\t\t\t} else if (value !== undefined) {\r\n\t\t\t\tstr.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str.join(\"&\");\r\n\t}\r\n\tfunction parseQueryString(str) {\r\n\t\tif (str === \"\" || str == null) return {};\r\n\t\tif (str.charAt(0) === \"?\") str = str.slice(1);\r\n\r\n\t\tvar pairs = str.split(\"&\"), params = {};\r\n\t\tforEach(pairs, function (string) {\r\n\t\t\tvar pair = string.split(\"=\");\r\n\t\t\tvar key = decodeURIComponent(pair[0]);\r\n\t\t\tvar value = pair.length === 2 ? decodeURIComponent(pair[1]) : null;\r\n\t\t\tif (params[key] != null) {\r\n\t\t\t\tif (!isArray(params[key])) params[key] = [params[key]];\r\n\t\t\t\tparams[key].push(value);\r\n\t\t\t}\r\n\t\t\telse params[key] = value;\r\n\t\t});\r\n\r\n\t\treturn params;\r\n\t}\r\n\tm.route.buildQueryString = buildQueryString;\r\n\tm.route.parseQueryString = parseQueryString;\r\n\r\n\tfunction reset(root) {\r\n\t\tvar cacheKey = getCellCacheKey(root);\r\n\t\tclear(root.childNodes, cellCache[cacheKey]);\r\n\t\tcellCache[cacheKey] = undefined;\r\n\t}\r\n\r\n\tm.deferred = function () {\r\n\t\tvar deferred = new Deferred();\r\n\t\tdeferred.promise = propify(deferred.promise);\r\n\t\treturn deferred;\r\n\t};\r\n\tfunction propify(promise, initialValue) {\r\n\t\tvar prop = m.prop(initialValue);\r\n\t\tpromise.then(prop);\r\n\t\tprop.then = function(resolve, reject) {\r\n\t\t\treturn propify(promise.then(resolve, reject), initialValue);\r\n\t\t};\r\n\t\tprop[\"catch\"] = prop.then.bind(null, null);\r\n\t\treturn prop;\r\n\t}\r\n\t//Promiz.mithril.js | Zolmeister | MIT\r\n\t//a modified version of Promiz.js, which does not conform to Promises/A+ for two reasons:\r\n\t//1) `then` callbacks are called synchronously (because setTimeout is too slow, and the setImmediate polyfill is too big\r\n\t//2) throwing subclasses of Error cause the error to be bubbled up instead of triggering rejection (because the spec does not account for the important use case of default browser error handling, i.e. message w/ line number)\r\n\tfunction Deferred(successCallback, failureCallback) {\r\n\t\tvar RESOLVING = 1, REJECTING = 2, RESOLVED = 3, REJECTED = 4;\r\n\t\tvar self = this, state = 0, promiseValue = 0, next = [];\r\n\r\n\t\tself.promise = {};\r\n\r\n\t\tself.resolve = function(value) {\r\n\t\t\tif (!state) {\r\n\t\t\t\tpromiseValue = value;\r\n\t\t\t\tstate = RESOLVING;\r\n\r\n\t\t\t\tfire();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t};\r\n\r\n\t\tself.reject = function(value) {\r\n\t\t\tif (!state) {\r\n\t\t\t\tpromiseValue = value;\r\n\t\t\t\tstate = REJECTING;\r\n\r\n\t\t\t\tfire();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t};\r\n\r\n\t\tself.promise.then = function(successCallback, failureCallback) {\r\n\t\t\tvar deferred = new Deferred(successCallback, failureCallback)\r\n\t\t\tif (state === RESOLVED) {\r\n\t\t\t\tdeferred.resolve(promiseValue);\r\n\t\t\t}\r\n\t\t\telse if (state === REJECTED) {\r\n\t\t\t\tdeferred.reject(promiseValue);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tnext.push(deferred);\r\n\t\t\t}\r\n\t\t\treturn deferred.promise\r\n\t\t};\r\n\r\n\t\tfunction finish(type) {\r\n\t\t\tstate = type || REJECTED;\r\n\t\t\tnext.map(function(deferred) {\r\n\t\t\t\tstate === RESOLVED ? deferred.resolve(promiseValue) : deferred.reject(promiseValue);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction thennable(then, successCallback, failureCallback, notThennableCallback) {\r\n\t\t\tif (((promiseValue != null && isObject(promiseValue)) || isFunction(promiseValue)) && isFunction(then)) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// count protects against abuse calls from spec checker\r\n\t\t\t\t\tvar count = 0;\r\n\t\t\t\t\tthen.call(promiseValue, function(value) {\r\n\t\t\t\t\t\tif (count++) return;\r\n\t\t\t\t\t\tpromiseValue = value;\r\n\t\t\t\t\t\tsuccessCallback();\r\n\t\t\t\t\t}, function (value) {\r\n\t\t\t\t\t\tif (count++) return;\r\n\t\t\t\t\t\tpromiseValue = value;\r\n\t\t\t\t\t\tfailureCallback();\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tm.deferred.onerror(e);\r\n\t\t\t\t\tpromiseValue = e;\r\n\t\t\t\t\tfailureCallback();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnotThennableCallback();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction fire() {\r\n\t\t\t// check if it's a thenable\r\n\t\t\tvar then;\r\n\t\t\ttry {\r\n\t\t\t\tthen = promiseValue && promiseValue.then;\r\n\t\t\t}\r\n\t\t\tcatch (e) {\r\n\t\t\t\tm.deferred.onerror(e);\r\n\t\t\t\tpromiseValue = e;\r\n\t\t\t\tstate = REJECTING;\r\n\t\t\t\treturn fire();\r\n\t\t\t}\r\n\r\n\t\t\tif (state === REJECTING) {\r\n\t\t\t\tm.deferred.onerror(promiseValue)\r\n\t\t\t}\r\n\r\n\t\t\tthennable(then, function () {\r\n\t\t\t\tstate = RESOLVING\r\n\t\t\t\tfire()\r\n\t\t\t}, function () {\r\n\t\t\t\tstate = REJECTING\r\n\t\t\t\tfire()\r\n\t\t\t}, function () {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (state === RESOLVING && isFunction(successCallback)) {\r\n\t\t\t\t\t\tpromiseValue = successCallback(promiseValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (state === REJECTING && isFunction(failureCallback)) {\r\n\t\t\t\t\t\tpromiseValue = failureCallback(promiseValue);\r\n\t\t\t\t\t\tstate = RESOLVING;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tm.deferred.onerror(e);\r\n\t\t\t\t\tpromiseValue = e;\r\n\t\t\t\t\treturn finish();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (promiseValue === self) {\r\n\t\t\t\t\tpromiseValue = TypeError();\r\n\t\t\t\t\tfinish();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthennable(then, function () {\r\n\t\t\t\t\t\tfinish(RESOLVED);\r\n\t\t\t\t\t}, finish, function () {\r\n\t\t\t\t\t\tfinish(state === RESOLVING && RESOLVED);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\tm.deferred.onerror = function(e) {\r\n\t\tif (type.call(e) === \"[object Error]\" && !e.constructor.toString().match(/ Error/)) {\r\n\t\t\tpendingRequests = 0;\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t};\r\n\r\n\tm.sync = function(args) {\r\n\t\tvar method = \"resolve\";\r\n\r\n\t\tfunction synchronizer(pos, resolved) {\r\n\t\t\treturn function(value) {\r\n\t\t\t\tresults[pos] = value;\r\n\t\t\t\tif (!resolved) method = \"reject\";\r\n\t\t\t\tif (--outstanding === 0) {\r\n\t\t\t\t\tdeferred.promise(results);\r\n\t\t\t\t\tdeferred[method](results);\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar deferred = m.deferred();\r\n\t\tvar outstanding = args.length;\r\n\t\tvar results = new Array(outstanding);\r\n\t\tif (args.length > 0) {\r\n\t\t\tforEach(args, function (arg, i) {\r\n\t\t\t\targ.then(synchronizer(i, true), synchronizer(i, false));\r\n\t\t\t});\r\n\t\t}\r\n\t\telse deferred.resolve([]);\r\n\r\n\t\treturn deferred.promise;\r\n\t};\r\n\tfunction identity(value) { return value; }\r\n\r\n\tfunction ajax(options) {\r\n\t\tif (options.dataType && options.dataType.toLowerCase() === \"jsonp\") {\r\n\t\t\tvar callbackKey = \"mithril_callback_\" + new Date().getTime() + \"_\" + (Math.round(Math.random() * 1e16)).toString(36)\r\n\t\t\tvar script = $document.createElement(\"script\");\r\n\r\n\t\t\twindow[callbackKey] = function(resp) {\r\n\t\t\t\tscript.parentNode.removeChild(script);\r\n\t\t\t\toptions.onload({\r\n\t\t\t\t\ttype: \"load\",\r\n\t\t\t\t\ttarget: {\r\n\t\t\t\t\t\tresponseText: resp\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\twindow[callbackKey] = undefined;\r\n\t\t\t};\r\n\r\n\t\t\tscript.onerror = function() {\r\n\t\t\t\tscript.parentNode.removeChild(script);\r\n\r\n\t\t\t\toptions.onerror({\r\n\t\t\t\t\ttype: \"error\",\r\n\t\t\t\t\ttarget: {\r\n\t\t\t\t\t\tstatus: 500,\r\n\t\t\t\t\t\tresponseText: JSON.stringify({\r\n\t\t\t\t\t\t\terror: \"Error making jsonp request\"\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\twindow[callbackKey] = undefined;\r\n\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tscript.onload = function() {\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\r\n\t\t\tscript.src = options.url\r\n\t\t\t\t+ (options.url.indexOf(\"?\") > 0 ? \"&\" : \"?\")\r\n\t\t\t\t+ (options.callbackKey ? options.callbackKey : \"callback\")\r\n\t\t\t\t+ \"=\" + callbackKey\r\n\t\t\t\t+ \"&\" + buildQueryString(options.data || {});\r\n\t\t\t$document.body.appendChild(script);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvar xhr = new window.XMLHttpRequest();\r\n\t\t\txhr.open(options.method, options.url, true, options.user, options.password);\r\n\t\t\txhr.onreadystatechange = function() {\r\n\t\t\t\tif (xhr.readyState === 4) {\r\n\t\t\t\t\tif (xhr.status >= 200 && xhr.status < 300) options.onload({type: \"load\", target: xhr});\r\n\t\t\t\t\telse options.onerror({type: \"error\", target: xhr});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tif (options.serialize === JSON.stringify && options.data && options.method !== \"GET\") {\r\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\");\r\n\t\t\t}\r\n\t\t\tif (options.deserialize === JSON.parse) {\r\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\");\r\n\t\t\t}\r\n\t\t\tif (isFunction(options.config)) {\r\n\t\t\t\tvar maybeXhr = options.config(xhr, options);\r\n\t\t\t\tif (maybeXhr != null) xhr = maybeXhr;\r\n\t\t\t}\r\n\r\n\t\t\tvar data = options.method === \"GET\" || !options.data ? \"\" : options.data;\r\n\t\t\tif (data && (!isString(data) && data.constructor !== window.FormData)) {\r\n\t\t\t\tthrow new Error(\"Request data should be either be a string or FormData. Check the `serialize` option in `m.request`\");\r\n\t\t\t}\r\n\t\t\txhr.send(data);\r\n\t\t\treturn xhr;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindData(xhrOptions, data, serialize) {\r\n\t\tif (xhrOptions.method === \"GET\" && xhrOptions.dataType !== \"jsonp\") {\r\n\t\t\tvar prefix = xhrOptions.url.indexOf(\"?\") < 0 ? \"?\" : \"&\";\r\n\t\t\tvar querystring = buildQueryString(data);\r\n\t\t\txhrOptions.url = xhrOptions.url + (querystring ? prefix + querystring : \"\");\r\n\t\t}\r\n\t\telse xhrOptions.data = serialize(data);\r\n\t\treturn xhrOptions;\r\n\t}\r\n\r\n\tfunction parameterizeUrl(url, data) {\r\n\t\tvar tokens = url.match(/:[a-z]\\w+/gi);\r\n\t\tif (tokens && data) {\r\n\t\t\tforEach(tokens, function (token) {\r\n\t\t\t\tvar key = token.slice(1);\r\n\t\t\t\turl = url.replace(token, data[key]);\r\n\t\t\t\tdelete data[key];\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn url;\r\n\t}\r\n\r\n\tm.request = function(xhrOptions) {\r\n\t\tif (xhrOptions.background !== true) m.startComputation();\r\n\t\tvar deferred = new Deferred();\r\n\t\tvar isJSONP = xhrOptions.dataType && xhrOptions.dataType.toLowerCase() === \"jsonp\"\r\n\t\tvar serialize = xhrOptions.serialize = isJSONP ? identity : xhrOptions.serialize || JSON.stringify;\r\n\t\tvar deserialize = xhrOptions.deserialize = isJSONP ? identity : xhrOptions.deserialize || JSON.parse;\r\n\t\tvar extract = isJSONP ? function(jsonp) { return jsonp.responseText } : xhrOptions.extract || function(xhr) {\r\n\t\t\tif (xhr.responseText.length === 0 && deserialize === JSON.parse) {\r\n\t\t\t\treturn null\r\n\t\t\t} else {\r\n\t\t\t\treturn xhr.responseText\r\n\t\t\t}\r\n\t\t};\r\n\t\txhrOptions.method = (xhrOptions.method || \"GET\").toUpperCase();\r\n\t\txhrOptions.url = parameterizeUrl(xhrOptions.url, xhrOptions.data);\r\n\t\txhrOptions = bindData(xhrOptions, xhrOptions.data, serialize);\r\n\t\txhrOptions.onload = xhrOptions.onerror = function(e) {\r\n\t\t\ttry {\r\n\t\t\t\te = e || event;\r\n\t\t\t\tvar unwrap = (e.type === \"load\" ? xhrOptions.unwrapSuccess : xhrOptions.unwrapError) || identity;\r\n\t\t\t\tvar response = unwrap(deserialize(extract(e.target, xhrOptions)), e.target);\r\n\t\t\t\tif (e.type === \"load\") {\r\n\t\t\t\t\tif (isArray(response) && xhrOptions.type) {\r\n\t\t\t\t\t\tforEach(response, function (res, i) {\r\n\t\t\t\t\t\t\tresponse[i] = new xhrOptions.type(res);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else if (xhrOptions.type) {\r\n\t\t\t\t\t\tresponse = new xhrOptions.type(response);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdeferred.resolve(response)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdeferred.reject(response)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdeferred[e.type === \"load\" ? \"resolve\" : \"reject\"](response);\r\n\t\t\t}\r\n\t\t\tcatch (e) {\r\n\t\t\t\tdeferred.reject(e);\r\n\t\t\t}\r\n\t\t\tfinally {\r\n\t\t\t\tif (xhrOptions.background !== true) m.endComputation()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tajax(xhrOptions);\r\n\t\tdeferred.promise = propify(deferred.promise, xhrOptions.initialValue);\r\n\t\treturn deferred.promise;\r\n\t};\r\n\r\n\t//testing API\r\n\tm.deps = function(mock) {\r\n\t\tinitialize(window = mock || window);\r\n\t\treturn window;\r\n\t};\r\n\t//for internal testing only, do not use `m.deps.factory`\r\n\tm.deps.factory = app;\r\n\r\n\treturn m;\r\n})(typeof window !== \"undefined\" ? window : {});\r\n\r\nif (typeof module === \"object\" && module != null && module.exports) module.exports = m;\r\nelse if (typeof define === \"function\" && define.amd) define(function() { return m });\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mithril/mithril.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}